---
title: "Re2014Sichuan-MBC"
output: html_document
---

Comparing two dataframes in R
http://stackoverflow.com/questions/30655456/comparing-data-frames-in-r/30655765

Set up github remote on github.com/dougwyu/Sichuan2014
https://www.r-bloggers.com/rstudio-and-github/
Open Terminal
```{bash}
git remote add origin https://github.com/dougwyu/Sichuan2014.git
git config remote.origin.url git@github.com:dougwyu/Sichuan2014.git
git pull -u origin master
git push -u origin master
```
Pull and Push buttons are now active


```{r setup, test methods}
# original filename:  Re2014_SiCMBC_Xiaoy0726.Rmd
# 2libs_otu_WithTax4R_orig.txt is original file with all taxonomic assignments. Some of the OTUs still have non-Arthropoda in them, so need to go back and make taxonomic subsets. I added "Site" to top of first column and fixed misspelling of kindom to kingdom
##### make sure that Source option is set to `Chunk output in Console` and do not select `Show Previews inline`
# before import to R, delete first line and "#OTU ID" in the second line by hand. change names of habitats type: Ag->CL, B->BB, E->EC, C->JC, M->MF. add habitats type to original table. separate taxon info by "\t"

#install.packages("iNEXT")
# devtools::install_github("davidnipperess/PDcalc")
# add packages that I will use
library(tidyverse) # includes all data-formatting packages as one big package (e.g. dplyr, tidyr, ggplot2, readr, readxl, tibble, and others)
library(vegan)
library(car)
library(breakaway)
library(iNEXT)
library(boral)
library(mvabund)
library(PDcalc)

```

```{r load and format data}
# help(read_tsv)
# this inputfile contains taxononomic assignments in the lower rows
# command from readr package, and you tell the command how to format the columns
inputfile <- "./data/Sichuan2014_MBC_OTU443.txt" # post phyloseq filtering and filtering for trees

gfgMB <- read_tsv(
  inputfile, col_names = TRUE, na = "NA",
  col_types = cols(
    Site = col_character(),
    Habitat = col_factor(c("BB", "CL", "EC", "JC", "MF", "NF")),
    Type = col_factor(c("1", "2", "3", "4", "5", "6")),
    Altitude = col_integer(),
    Weather = col_integer()
    )
)
gfgMB <- tbl_df(gfgMB)


#gfgMB <- gfgMB %>% filter(!Site %in% c("BB02", "JC04"))  # These two sites were identified below as being compositional outliers. JC04 (row 2) has very few species.  BB02 (row 38) also has few species (more than JC04) but they appear to be compositional outliers.

```

```{r environment dataset}
# make environment dataset
habitat <- gfgMB %>% dplyr::select(Site:Weather)
habitat <- habitat %>% dplyr::filter(!is.na(Habitat)) # remove taxonomy rows
```

```{r community build}

community <- gfgMB %>% dplyr::select(starts_with("Cluster_"))
# otuvector <- colnames(community)
community_t <- t(community)
community_t <- as.data.frame(community_t)
community_t <- rownames_to_column(community_t)
colnames(community_t) <- c("otu", gfgMB$Site) # add column names

communityAll_t <- community_t %>% filter(phylum=="Arthropoda")
communityAll_t <- community_t %>% select(-c(kingdom:species))
communityAll <- t(communityAll_t)
colvector <- communityAll[1,] # make a vector of the first row, which has the otu names
communityAll <- as.data.frame(communityAll)
colnames(communityAll) <-  colvector # add the otu names to the column names
communityAll <- communityAll[-1,]
# convert the columns to numeric from factor
# http://stackoverflow.com/questions/2288485/how-to-convert-a-data-frame-column-to-numeric-type
communityAll <- sapply(communityAll, function(x) as.numeric(as.character(x))) # sapply applies a function to each column, and the function is:  function(x) as.numeric(as.character(x)).  Cannot convert factors to numeric directly. first convert to character, then to numeric
communityAll <- as.data.frame(communityAll) # then convert to df

```

```{r phyloseq filtering, eval=FALSE, include=FALSE}
# no longer need to run this code chunk because we have already used phyloseq to filter out small OTUs
# gsub("[[:punct:][:space:]]", "-", Sys.time()) #time will be shown
# source("https://bioconductor.org/biocLite.R") # to install phyloseq package
# biocLite("phyloseq")
library("phyloseq"); packageVersion("phyloseq")
library("data.table"); packageVersion("data.table")
library("ggplot2"); packageVersion("ggplot2")

TotalCounts <- c(colSums(communityAll))

tdt = data.table(colnames(communityAll),TotalCounts = colSums(communityAll),OTU = colnames(communityAll))

ggplot(tdt, aes(TotalCounts)) + 
  geom_histogram() + 
  ggtitle("Histogram of Total Counts")

tdt[(TotalCounts <= 0), .N]
tdt[(TotalCounts <= 1), .N]
tdt[(TotalCounts <= 2), .N]

taxcumsum = tdt[, .N, by = TotalCounts]
setkey(taxcumsum, TotalCounts)
taxcumsum[, CumSum := cumsum(N)]
# Define the plot
pCumSum = ggplot(taxcumsum, aes(TotalCounts, CumSum)) + 
  geom_point() +
  xlab("Filtering Threshold, Minimum Total Counts") +
  ylab("OTUs Filtered") +
  ggtitle("OTUs that would be filtered vs. the minimum count threshold")
pCumSum
pCumSum + xlim(0, 100)
pCumSum + xlim(0, 200)
pCumSum + xlim(0, 300)
pCumSum + xlim(0, 400)
pCumSum + xlim(0, 600)
pCumSum + xlim(0, 800)
pCumSum + xlim(0, 2000)
pCumSum + xlim(0, 20000)

## phyloseq-class experiment-level object
## otu_table()   OTU Table:         [ 3426 taxa and 34 samples ]
## sample_data() Sample Data:       [ 34 samples by 11 sample variables ]
## tax_table()   Taxonomy Table:    [ 3426 taxa by 7 taxonomic ranks ]
## phy_tree()    Phylogenetic Tree: [ 3426 tips and 3424 internal nodes ]

## from above result, we decide use 2 thresholds to filter those small otus: 120 (>=120) and 40 (>=40)
## 40 gives us a table with 443 OTUs. This is the table that we are already reading. 
commMBC.120 <- communityAll[ ,colSums(communityAll)>=120] ## 336 otus remain
commMBC.120 <- commMBC.120[ rowSums(commMBC.120)>0,]
rowSums(commMBC.120)
commMBC.120 <- commMBC.120[-38,] #number 38 site has very few otu and reads number

commMBC.40 <- communityAll[ ,colSums(communityAll)>=40] ## 448 otus remain
commMBC.40 <- commMBC.40[ rowSums(commMBC.40)>0,]
rowSums(commMBC.40)
commMBC.40 <- commMBC.40[-38,]
colnames(commMBC.40)

```

```{r NMDS, }
community <- communityAll
rownames(community)
#community <- commMBC.120
#community <- commMBC.40
community <- community[habitat$Site!="JC04",]
habitatN <- habitat[habitat$Site!="JC04",]

# community <- community[-38,]
# habitatN <- habitat[-38,]


### do NMDS analysis to see basic patterns ####
community.jmds <- metaMDS(community, distance = "jaccard", trymax = 40, binary=TRUE)
community.jmds <- metaMDS(community, distance = "jaccard", binary = TRUE, previous.best = community.jmds)
 
stressplot(community.jmds)
```

```{r ordiellipse plot, }
#### plot the communities
levels(habitatN$Habitat)
(sprichness <- specnumber(community, MARGIN = 1)) # number of species per site
with(habitat, ordisurf(community.jmds, sprichness, main="", cex=0.5))
# with(habitat, ordisurf(community.jmds, Altitude, main="", cex=0.5))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("blue"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("BB"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("green"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("CL"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("red"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("EC"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("blue"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("JC"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("darkgreen"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("MF"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("darkgreen"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("NF"))))

```

```{r ordihull plot, }
#### plot the communities
levels(habitatN$Habitat)
(sprichness <- specnumber(community, MARGIN = 1)) # number of species per site
with(habitat, ordisurf(community.jmds, sprichness, main="", cex=0.5))
# with(habitat, ordisurf(community.jmds, Altitude, main="", cex=0.5))

with(habitatN, ordihull(community.jmds, Habitat, cex=.5, draw="polygon", col=c("blue"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("BB"))))

with(habitatN, ordihull(community.jmds, Habitat, cex=.5, draw="polygon", col=c("green"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("CL"))))

with(habitatN, ordihull(community.jmds, Habitat, cex=.5, draw="polygon", col=c("red"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("EC"))))

with(habitatN, ordihull(community.jmds, Habitat, cex=.5, draw="polygon", col=c("blue"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("JC"))))

with(habitatN, ordihull(community.jmds, Habitat, cex=.5, draw="polygon", col=c("darkgreen"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("MF"))))

with(habitatN, ordihull(community.jmds, Habitat, cex=.5, draw="polygon", col=c("darkgreen"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("NF"))))

```


```{r ordiplots}
# These commands are ways to identify points
orditorp(community.jmds, labels = habitatN$Site, dis="sites", pcol = "gray")
ordipointlabel(community.jmds, dis="sites")

#p1 <- plot(community.jmds, dis="sites")
#identify(p1, "sites") # interactive method to identify sites by row number. Click on the points that you want to identify. When you have clicked on all the points, click on the Finish button at top right of Plot window. 
```

Across the various taxonomic subsets, sites 2 (BB02) and 38 (JC04) remain compositional outliers. In the community_insecta_nosngltons dataset, there are only 3 OTUs in site 2 and 1 OTU in site 38. There are other sites with low numbers of species (e.g. 27 & 28), but they are not compositional outliers. So we should remove these sites from the community and habitat datasets, starting right at the beginning of the analysis. 


```{r specpool,}
##########

############### alpha diversity: breakaway, specpool(vegan), iNEXT ######
######### otu table with original reads number ######
###### vegan specpool ###
# attach(habitatN) # bad practice
(pool1 <- specpool(community, habitatN$Habitat))

#   Species     chao  chao.se    jack1 jack1.se    jack2     boot  boot.se  n
#BB     127 228.2500 32.52787 194.5000 25.79826 236.7222 156.1907 12.40703 10
#CL     212 338.6943 36.31374 299.1875 26.60805 354.4292 249.7093 12.68406 16
#EC      84 140.8969 21.74079 128.6250 20.80377 154.0179 103.6627 11.12558  8
#JC     105 232.2995 44.94411 167.7273 23.60137 211.6636 131.2092 11.21026 11
#MF     141 285.6838 43.12727 222.7778 32.32856 276.6389 175.8731 14.56185  9
#NF     229 441.6250 51.79186 355.0000 43.14008 439.8095 282.3105 21.72050 15
#op <- par(mfrow = c(1,2))
boxplot(specnumber(community)~habitatN$Habitat)
boxplot(specnumber(community)/specpool2vect(pool1)~habitatN$Habitat)
poolaccum(community)
estaccumR(community)
```

```{r breakaway quantitative, eval=FALSE, include=FALSE}
## as breakaway required, make a frequency table for each habitat
# DY:  fix this
BB <- community[1:10,]
CL <- community[11:26,]
EC <- community[27:34,]
JC <- community[35:45,]
MF <- community[46:54,]
NF <- community[55:69,]

BB <- BB[,colSums(BB)>0] # keep those observed otu 
CL <- CL[,colSums(CL)>0]
EC <- EC[,colSums(EC)>0]
JC <- JC[,colSums(JC)>0]
MF <- MF[,colSums(MF)>0]
NF <- NF[,colSums(NF)>0]

BB.fq <- matrix(c(colSums(BB),colSums(BB)), ncol = 2)
#BB.fq <- BB.fq[sort(BB.fq[1,]),]
BB.fq <- BB.fq[order(rowSums(BB.fq)),]
BB.fq.ns <- BB.fq[rowSums(BB.fq)>2,]
###### breakaway ###########
breakaway(BB.fq)
chao1(BB.fq)
chao1_bc(BB.fq)
chao_bunge(BB.fq)
wlrm_transformed(BB.fq)
wlrm_untransformed(BB.fq)
breakaway_nof1(BB.fq.ns)
#
CL.fq <- matrix(c(colSums(CL),colSums(CL)),ncol = 2)
CL.fq <- CL.fq[order(rowSums(CL.fq)),]
CL.fq.ns <- CL.fq[rowSums(CL.fq)>2,]
#CL.fq.ns
breakaway(CL.fq)
breakaway_nof1(CL.fq.ns)
#
EC.fq <- matrix(c(colSums(EC),colSums(EC)),ncol = 2)
EC.fq <- EC.fq[order(rowSums(EC.fq)),]
EC.fq.ns <- EC.fq[rowSums(EC.fq)>2,]
breakaway(EC.fq)
breakaway_nof1(EC.fq.ns)
#
JC.fq <- matrix(c(colSums(JC),colSums(JC)),ncol = 2)
JC.fq <- JC.fq[order(rowSums(JC.fq)),]
JC.fq.ns <- JC.fq[rowSums(JC.fq)>2,]
breakaway(JC.fq)
breakaway_nof1(JC.fq.ns)
#
MF.fq <- matrix(c(colSums(MF),colSums(MF)),ncol = 2)
MF.fq <- MF.fq[order(rowSums(MF.fq)),]
MF.fq.ns <- MF.fq[rowSums(MF.fq)>2,]
breakaway(MF.fq)
breakaway_nof1(MF.fq.ns)
#
NF.fq <- matrix(c(colSums(NF),colSums(NF)),ncol = 2)
NF.fq <- NF.fq[order(rowSums(NF.fq)),]
NF.fq.ns <- NF.fq[rowSums(NF.fq)>2,]
breakaway(NF.fq)
breakaway_nof1(NF.fq.ns)

```

```{r breakaway binary,}
##################### use binary data ###################
communityB <- community
communityB[communityB>1] <- 1

########### NMDS #########
community.jmds <- metaMDS(communityB, distance = "jaccard", trymax = 40, binary = TRUE)
community.jmds <- metaMDS(communityB, distance = "jaccard", binary = TRUE, previous.best = community.jmds)

stressplot(community.jmds)

#### plot the communities
levels(habitatN$Habitat)
(sprichness <- specnumber(communityB, MARGIN = 1)) # number of species per site
with(habitat, ordisurf(community.jmds, sprichness, main="", cex=0.5))
# with(habitat, ordisurf(community.jmds, Altitude, main="", cex=0.5))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("blue"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("BB"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("green"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("CL"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("red"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("EC"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("blue"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("JC"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("darkgreen"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("MF"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("darkgreen"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("NF"))))

######### vegan specpool ######
pool2 <- specpool(communityB, habitatN$Habitat)
pool2
#   Species     chao  chao.se    jack1 jack1.se    jack2     boot  boot.se  n
#BB     127 228.2500 32.52787 194.5000 25.79826 236.7222 156.1907 12.40703 10
#CL     212 338.6943 36.31374 299.1875 26.60805 354.4292 249.7093 12.68406 16
#EC      84 140.8969 21.74079 128.6250 20.80377 154.0179 103.6627 11.12558  8
#JC     105 232.2995 44.94411 167.7273 23.60137 211.6636 131.2092 11.21026 11
#MF     141 285.6838 43.12727 222.7778 32.32856 276.6389 175.8731 14.56185  9
#NF     229 441.6250 51.79186 355.0000 43.14008 439.8095 282.3105 21.72050 15
#op <- par(mfrow = c(1,2))
boxplot(specnumber(communityB)~Habitat)
boxplot(specnumber(communityB)/specpool2vect(pool2)~Habitat)
poolaccum(communityB)
estaccumR(communityB)
## as breakaway required, make a frequency table for each habitat
BB <- communityB[1:10,]
CL <- communityB[11:26,]
EC <- communityB[27:34,]
JC <- communityB[35:45,]
MF <- communityB[46:54,]
NF <- communityB[55:69,]

BB <- BB[,colSums(BB)>0] # keep those observed otu 
CL <- CL[,colSums(CL)>0]
EC <- EC[,colSums(EC)>0]
JC <- JC[,colSums(JC)>0]
MF <- MF[,colSums(MF)>0]
NF <- NF[,colSums(NF)>0]

BB.fq <- matrix(c(colSums(BB),colSums(BB)),ncol = 2)
#BB.fq <- BB.fq[sort(BB.fq[1,]),]
BB.fq <- BB.fq[order(rowSums(BB.fq)),]
BB.fq.ns <- BB.fq[rowSums(BB.fq)>2,]
#   Species     chao  chao.se    jack1 jack1.se    jack2     boot  boot.se  n
#BB     127 228.2500 32.52787 194.5000 25.79826 236.7222 156.1907 12.40703 10
breakaway(BB.fq)
## The best estimate of total diversity is 248 with std error 1
chao1(BB.fq)
chao1_bc(BB.fq)
chao_bunge(BB.fq)
wlrm_transformed(BB.fq)
wlrm_untransformed(BB.fq)
breakaway_nof1(BB.fq.ns)
## The best estimate of total diversity is 176 with std error 2
####
#   Species     chao  chao.se    jack1 jack1.se    jack2     boot  boot.se  n
#CL     212 338.6943 36.31374 299.1875 26.60805 354.4292 249.7093 12.68406 16
CL.fq <- matrix(c(colSums(CL),colSums(CL)),ncol = 2)
CL.fq <- CL.fq[order(rowSums(CL.fq)),]
CL.fq.ns <- CL.fq[rowSums(CL.fq)>2,]
#CL.fq.ns
breakaway(CL.fq)
#The best estimate of total diversity is 679 with std error 1 
breakaway_nof1(CL.fq.ns)
## The best estimate of total diversity is 589 with std error 2
####
#   Species     chao  chao.se    jack1 jack1.se    jack2     boot  boot.se  n
#EC      84 140.8969 21.74079 128.6250 20.80377 154.0179 103.6627 11.12558  8
EC.fq <- matrix(c(colSums(EC),colSums(EC)),ncol = 2)
EC.fq <- EC.fq[order(rowSums(EC.fq)),]
EC.fq.ns <- EC.fq[rowSums(EC.fq)>2,]
breakaway(EC.fq)
## The best estimate of total diversity is 146 with std error 1
breakaway_nof1(EC.fq.ns)
## The best estimate of total diversity is 98 with std error 2
###
#   Species     chao  chao.se    jack1 jack1.se    jack2     boot  boot.se  n
#JC     105 232.2995 44.94411 167.7273 23.60137 211.6636 131.2092 11.21026 11
JC.fq <- matrix(c(colSums(JC),colSums(JC)),ncol = 2)
JC.fq <- JC.fq[order(rowSums(JC.fq)),]
JC.fq.ns <- JC.fq[rowSums(JC.fq)>2,]
breakaway(JC.fq)
## The best estimate of total diversity is 202 with std error 1
breakaway_nof1(JC.fq.ns)
## The best estimate of total diversity is 136 with std error 3
### 
#   Species     chao  chao.se    jack1 jack1.se    jack2     boot  boot.se  n
#MF     141 285.6838 43.12727 222.7778 32.32856 276.6389 175.8731 14.56185  9
MF.fq <- matrix(c(colSums(MF),colSums(MF)),ncol = 2)
MF.fq <- MF.fq[order(rowSums(MF.fq)),]
MF.fq.ns <- MF.fq[rowSums(MF.fq)>2,]
breakaway(MF.fq)
## The best estimate of total diversity is 242 with std error 1
breakaway_nof1(MF.fq.ns) 
## The best estimate of total diversity is 153 with std error 2
###
#   Species     chao  chao.se    jack1 jack1.se    jack2     boot  boot.se  n
#NF     229 441.6250 51.79186 355.0000 43.14008 439.8095 282.3105 21.72050 15
NF.fq <- matrix(c(colSums(NF),colSums(NF)),ncol = 2)
NF.fq <- NF.fq[order(rowSums(NF.fq)),]
NF.fq.ns <- NF.fq[rowSums(NF.fq)>2,]
breakaway(NF.fq)
## The best estimate of total diversity is 485 with std error 1
breakaway_nof1(NF.fq.ns)
## The best estimate of total diversity is 353 with std error 2

####### iNEXT ############
## example for abundance based data (data.frame)
data(bird)
# out2 <- iNEXT(bird, q=0, datatype="abundance")
# ggiNEXT(out2)
data(ant)
str(ant)
t <- round(seq(10, 500, length.out=20))
out3 <- iNEXT(ant$h500m, q=1, datatype="incidence_freq", size=t, se=FALSE)
out3$iNextEst
ggiNEXT(out3)


rownames(communityB)
communityB_t <- t(communityB)
colnames(communityB_t)
rownames(communityB_t)
BB_t <- communityB_t[,1:10]
CL_t <- communityB_t[,11:26]
EC_t <- communityB_t[,27:34]
JC_t <- communityB_t[,35:45]
MF_t <- communityB_t[,46:54]
NF_t <- communityB_t[,55:69]

rowSums(BB_t)
rname <- rownames(BB_t)
cname <- c("BB","CL","EC","JC","MF","NF")
#   Species     chao  chao.se    jack1 jack1.se    jack2     boot  boot.se  n
#BB     127 228.2500 32.52787 194.5000 25.79826 236.7222 156.1907 12.40703 10
#CL     212 338.6943 36.31374 299.1875 26.60805 354.4292 249.7093 12.68406 16
#EC      84 140.8969 21.74079 128.6250 20.80377 154.0179 103.6627 11.12558  8
#JC     105 232.2995 44.94411 167.7273 23.60137 211.6636 131.2092 11.21026 11
#MF     141 285.6838 43.12727 222.7778 32.32856 276.6389 175.8731 14.56185  9
#NF     229 441.6250 51.79186 355.0000 43.14008 439.8095 282.3105 21.72050 15
comm4inext <- matrix(c(rowSums(BB_t), rowSums(CL_t), rowSums(EC_t), rowSums(JC_t), rowSums(MF_t), rowSums(NF_t)), ncol = 6)
comm4inext <- rbind(c(10, 16, 8, 11, 9, 15), comm4inext)
rownames(comm4inext) <- rname
colnames(comm4inext) <- cname
comm4inext

outcomm0 <- iNEXT(comm4inext, q=0, datatype="incidence_freq")
ggiNEXT(outcomm0, type=1)
ggiNEXT(outcomm0, type=2)
ggiNEXT(outcomm0, type=3)
outcomm1 <- iNEXT(comm4inext, q=1, datatype="incidence_freq")
ggiNEXT(outcomm1)
outcomm0$DataInfo

data(ciliates) # raw incidence data
ciliates[[1]]
str(ciliates)
```

```{r beta diversity}
############## Boral #######
#mcmc.control <- list(n.burnin = 100, n.iteration = 1000, n.thin = 10)
mcmc.control <- list(n.burnin = 300, n.iteration = 3000, n.thin = 30)
mcmc.control4 <- list(n.burnin = 10000, n.iteration = 40000, n.thin = 30, seed = 123)

colnames(community) <- c(1:443)
colnames(communityB) <- c(1:443)

#### negative binomial 
#comm.fit.nb3 <- boral(community, family = "negative.binomial", num.lv = 3, row.eff = "fixed", calc.ics = FALSE, mcmc.control = mcmc.control) ## failed
commB.fit.nb3 <- boral(communityB, family = "negative.binomial", num.lv = 3, row.eff = "fixed", calc.ics = FALSE, mcmc.control = mcmc.control)

#### possion
comm.fit.pb3 <- boral(communityB, family = "poisson", num.lv = 3, row.eff = "fixed", calc.ics = FALSE, mcmc.control = mcmc.control)
comm.fit.pb3.4 <- boral(communityB, family = "poisson", num.lv = 3, row.eff = "fixed", calc.ics = FALSE, mcmc.control = mcmc.control4)

summary(comm.fit.pb3.4)
par(mfrow = c(2,2))
plot(comm.fit.pb3.4) ## Plots used in residual analysis, 
#dev.off()
par(mfrow = c(1,1))
lvsplot(comm.fit.pb3.4)

comm.fit.pb2.4 <- boral(communityB, family = "poisson", num.lv = 2, row.eff = "fixed", calc.ics = FALSE, mcmc.control = mcmc.control4)


summary(comm.fit.pb2.4)
par(mfrow = c(2,2))
plot(comm.fit.pb2.4) ## Plots used in residual analysis, 
#dev.off()
par(mfrow = c(1,1))
lvsplot(comm.fit.pb2.4)

########################################
###### tabasco ########################
vegemite(communityB)
tabasco(communityB)
x0 <- colSums(communityB[1:10,])
x1 <- colSums(communityB[11:26,])
x2 <- colSums(communityB[27:34,])
x3 <- colSums(communityB[35:45,])
x4 <- colSums(communityB[46:54,])
x5 <- colSums(communityB[55:69,])

habSum <- matrix(c(x0,x1,x2,x3,x4,x5),ncol = 443)
colnames(habSum)
rownames(habSum)
row <- c("BB","CL","EC","JC","MF","NF")
col <- c(1:443)
dimnames(habSum) <- list(row,col)

vegemite(habSum,scale = "Hill")
tabasco(habSum)

habSum1 <- matrix(c(x0,x2,x3,x4,x5),ncol = 443)
row <- c("BB","EC","JC","MF","NF")
col <- c(1:443)
dimnames(habSum1) <- list(row,col)

habSum1 <- habSum1[,colSums(habSum1)]

vegemite(habSum1,scale = "Hill")
tabasco(habSum1)

###### ####

knitr::opts_chunk$set(echo = TRUE)
```

```{r PD calc} 

########### phylocurve ##############

library(PDcalc)
library(ape)

otu_table <- communityB
tree <- read.tree("./data/reIDotu443_outgroupOnychophora_tree.newick")

pd <- phylodiv(otu_table, tree)
pd <- phylocurve(otu_table, tree, stepm = 10, subsampling = "species", replace = FALSE)

###############
# install.packages("phylocurve")


####### beta diversity ######
#### PCA 
#install.packages("SparseM") ## need by library 'car'
#library(foreign)
#library(vegan)
#library(car)
#commNosrB <- commNosr
#commNosrB[commNosrB<3] <- 0 # according before results and field work experience, #JC forest seems get more alpha diversity. so drop those single read and double #reads cell
#commNosrB[commNosrB>1] <- 1
#
#hab <- habitat[,2:4]
#comm.pca <- rda(commNosrB)
#comm.pca <- rda(commNosrB~Habitat,habitat)
#comm.pca <- rda(commNosrB~Habitat*Altitude*Weather,habitat)
#summary(comm.pca)
#plot(comm.pca)


# #######


```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

