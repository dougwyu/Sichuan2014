---
title: "Sichuan2014_metabarcode pipeline"
author: "Douglas Yu"
date: "22/10/2017"
output: html_document
---

I have set up Github repo on github.com/dougwyu/Sichuan2014

filename:  Sichuan2014_reduced.Rmd

Make sure that Source option is set to `Chunk output in Console` and do not select `Show Previews inline`


## Tentative conclusions

1) Mosaic forest composition is indistinguishable from Natural forest, and significantly different from the monospecies 
2) Mosaic forest has higher species richness and higher Shannon richness than the monospecies plantations:  JC, EC, and BB
2) The source of the beta diversity in this system is entirely turnover, which means that each of the monospecies plantations has its own 


## To dos:

1. *mvabund* *this software is more mature*
    a. do model selection (drop1? cross validation?) to choose best model for explaining Sichuan2014 community:  habitatMFNF, elevation_m, weather_value, interactions
    b. do model selection (drop1? cross validation?) to choose best model for explaining Sichuan2014 community:  Landsat variables, elevation_m, weather_value
    c. can we calculate deviance explained from mvabund models?
    d. (?) rewrite anova.manyglm code to run in parallel (might not be worth the effort)

2. *boral*   *this software is new and is Bayesian, so might choke on our dataset*
    a. do model selection (ssvs.index) to choose best model for explaining Sichuan2014 community:  habitatMFNF, elevation_m, weather_value, interactions
    b. do model selection (ssvs.index) to choose best model for explaining Sichuan2014 community:  Landsat variables, elevation_m, weather_value
    c. calculate deviance using res.cor$trace method
    
3. *SpeciesMix*  *cannot get this to run*
    a. cluster the 746 OTUs into archetypal Groups that respond similarly to the environment and then see if the groups have any taxonomic affinities

4. Also do these analyses with Fangyuan's bird data?  (prob not)
5. Also include Kat's results about mixed vs. mosaic?  (prob not)


```{r setup, packages}
library(tidyverse) # includes all data-formatting packages as one big package (dplyr, tidyr, ggplot2, readr, readxl, tibble, and others)
library(vegan)
library(beanplot)
library(car)
library(iNEXT)
library(iNextPD)
library(ade4)
library(boral)
library(mvabund)
library(RColorBrewer)
library(betapart)
library(forcats)
library(stringr)
library(SpeciesMix)

library(PDcalc)
library(ape)
library(phylocurve)
sessionInfo()
```


```{r load and format data}
# help(read_tsv)
# this inputfile contains taxononomic assignments in the lower rows

# inputfile <- "./data/Sichuan2014_MBC_OTU443.txt" # post phyloseq filtering and filtering for trees
# inputfile <- "./data/2014MBC_otu746table_with_Env20.txt" # post phyloseq filtering and filtering for trees, using final bioinformatics pipeline with vsearch and RDP Classifier and phyloseq at min20reads

inputfile <- "./data/2014MBC_20reads_746otu_Landsat.txt" # post phyloseq filtering and filtering for trees, using final bioinformatics pipeline with vsearch and RDP Classifier and phyloseq at min20reads, with landsat data

# command from readr package, with options on formatting the columns
gfgMB <- read_tsv(
   inputfile, col_names = TRUE, na = "NA",
   col_types = cols(
     Site = col_character(),
     Habitat = col_factor(c("BB", "CL", "EC", "JC", "MF", "NF")),
     Type = col_factor(c("1", "2", "3", "4", "5", "6")),
     Altitude = col_integer(),
     sampling_time = col_date(format = "%d/%m/%Y"),
     weather_value = col_factor(c("cloudy", "sunny", "rainy")),
     Landsat_value = col_factor(c("1", "2", "3", "4", "5", "6")),
     longitude = col_double(),
     latitude = col_double(),
     Elevation_m = col_integer()
     )
 )

gfgMB <- tbl_df(gfgMB)

# with(gfgMB, plot(Altitude ~ Elevation_m, col=as.numeric(Habitat)))  # Altitude variable is not reliable;  use Elevation_m instead, which is calculated from DEM
```

```{r environment dataset}
# make environment dataset
habitat <- gfgMB %>% dplyr::select(Site:Simpson_evenness_index)
habitat <- habitat %>% dplyr::filter(!is.na(Habitat)) # remove taxonomy rows
colnames(habitat)[11:80] <- paste0("x", colnames(habitat)[11:80]) # column names need to start with a letter
```

```{r community build}
community <- gfgMB %>% dplyr::select(starts_with("Cluster"))
# otuvector <- colnames(community)
community_t <- t(community)
community_t <- as.data.frame(community_t)
community_t <- rownames_to_column(community_t)
colnames(community_t) <- c("otu", gfgMB$Site) # add column names

communityAll_t <- community_t %>% filter(phylum=="Arthropoda")
communityAll_t <- community_t %>% select(-c(kingdom:species))
communityAll <- t(communityAll_t)
colvector <- communityAll[1,] # make a vector of the first row, which has the otu names
communityAll <- as.data.frame(communityAll)
colnames(communityAll) <-  colvector # add the otu names to the column names
communityAll <- communityAll[-1,]
# convert the columns to numeric from factor
# http://stackoverflow.com/questions/2288485/how-to-convert-a-data-frame-column-to-numeric-type
communityAll <- sapply(communityAll, function(x) as.numeric(as.character(x))) # sapply applies a function to each column, and the function is:  function(x) as.numeric(as.character(x)).  Cannot convert factors to numeric directly. first convert to character, then to numeric
communityAll <- as.data.frame(communityAll) # then convert to df
```


Filter out sites with (1) very low numbers of reads, (2) very low numbers of species
```{r filter out sites, }
community <- communityAll
community[community < 3] <- 0 # set small cells to 0
habitat$rowsums <- rowSums(community)
habitat$sprichness <- specnumber(community, MARGIN = 1) # number of species per site

# View(habitat) 
# keep only sites that have more than 100 reads (removed 2)
community <- community %>% filter(habitat$rowsums > 100)
habitatN <- habitat %>% filter(habitat$rowsums > 100)
rowSums(community)

# keep only sites that have >=5 species (removed 68 - 64 = 4 sites)
community <- community %>% filter(habitatN$sprichness >= 5)
habitatN <- habitatN %>% filter(habitatN$sprichness >= 5)

habitatN <- droplevels(habitatN)

# should I rarefy the dataset?
# with(habitatN, plot(sprichness ~ rowsums))
# with(habitatN, abline(lm(sprichness~rowsums)))
# sprichness_mod <- with(habitatN, lm(sprichness ~ rowsums)); summary(sprichness_mod)
# sort(rowSums(community)) 
# There is no clear relationship between row sums and species richness, except that the max species richness is higher between 15,000 and 60,000 compared to < 15,000 reads.  But lots of high read number sites sites have few species.  So no call for rarefaction


# data(BCI)
# S <- specnumber(BCI) # observed number of species
# (raremax <- min(rowSums(BCI)))
# Srare <- rarefy(BCI, raremax)
# plot(S, Srare, xlab = "Observed No. of Species", ylab = "Rarefied No. of Species")
# abline(0, 1)
# rarecurve(BCI, step = 20, sample = raremax, col = "blue", cex = 0.6)
```

```{r save datasets for GDM, eval=FALSE, include=FALSE}
write.table(community, "GDM_community.txt", sep = "\t")
write.table(habitatN, "GDM_environment.txt", sep = "\t")
```

```{r NMDS}
### do NMDS analysis to see basic patterns ####
communityB <- community
communityB[communityB>1] <- 1 # binary
rownames(communityB) # 58 rows
community.jmds <- metaMDS(communityB, distance = "jaccard", trymax = 40, binary=TRUE)
community.jmds <- metaMDS(communityB, distance = "jaccard", binary = TRUE, previous.best = community.jmds)
stressplot(community.jmds)
```

```{r ordispider plot, }
#### plot the communities
levels(habitatN$Habitat)
(sprichness <- specnumber(community, MARGIN = 1)) # number of species per site
colvec <- brewer.pal(5, "Set1")

# with(habitatN, ordisurf(community.jmds, sprichness, main="NMDS - species richness contour", cex=0.5, col = "grey"))
with(habitatN, ordisurf(community.jmds, Altitude, main=" NMDS - Altitude contour", cex=0.5, col = "grey"))

with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("BB"))))

with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[1]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("CL"))))

with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("EC"))))

with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("JC"))))

with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("MF"))))

with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("NF"))))

```

```{r}
tabasco(community, use = community.jmds, labCol = habitatN$Habitat, col = brewer.pal(3, "Oranges"))
```

Ordiellipse plots cover the 95% CIs for the species points, not the site points
```{r ordiellipse plot, eval=FALSE, include=FALSE}
#### plot the communities
levels(habitatN$Habitat) 
(sprichness <- specnumber(community, MARGIN = 1)) # number of species per site

with(habitatN, ordisurf(community.jmds, sprichness, main="", cex=0.5, col = "grey"))
# with(habitat, ordisurf(community.jmds, Altitude, main="", cex=0.5))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("BB"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[1]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("CL"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("EC"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("JC"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("darkblue"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("MF"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("darkblue"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("NF"))))

```

If we want to identify individual points, we can use these commands. but not necessary now.
```{r ordiplots, eval=FALSE, include=FALSE}
# These commands are ways to identify points 
orditorp(community.jmds, labels = habitatN$Site, dis="sites", pcol = "gray")
ordipointlabel(community.jmds, dis="sites")

#p1 <- plot(community.jmds, dis="sites")
#identify(p1, "sites") # interactive method to identify sites by row number. Click on the points that you want to identify. When you have clicked on all the points, click on the Finish button at top right of Plot window. 
```

```{r specpool, }
######### otu table with original reads number ######
(pool1 <- specpool(communityB, habitatN$Habitat))
```

   Species     chao   chao.se    jack1 jack1.se    jack2     boot  boot.se  n
BB     131 344.4222  65.95468 218.1111 34.50103 280.7222 167.1569 15.33980  9
CL     271 519.8889  55.57037 420.3333 45.49188 520.3714 334.5948 21.47996 15
EC      88 149.7347  22.81217 135.1429 22.58589 161.9286 108.8202 11.28787  7
JC     124 345.4171  72.52752 206.7273 33.42192 268.6636 158.0417 15.29339 11
MF     161 536.5556 108.47768 276.5556 45.25047 364.0556 208.2756 18.89686  9
NF     259 677.2722  92.87942 432.5385 60.39515 561.3654 330.4070 26.96634 13

```{r}
beanplot(specnumber(communityB)~habitatN$Habitat, col = c("grey", "white"))
```

```{r iNEXT}
# # example for incidence based data
# data(ant)
# str(ant)
# t <- seq(1, 700, by=10)
# out.inc <- iNEXT(ant, q=0, datatype="incidence_freq", size=t)
# ggiNEXT(out.inc, type = 1)
# out.inc$DataInfo
# vignette ("Introduction", package="iNEXT")
# http://chao.stat.nthu.edu.tw/wordpress/wp-content/uploads/software/iNEXT_UserGuide.pdf


BB <- communityB %>% filter(habitatN$Habitat %in% c("BB"))
CL <- communityB %>% filter(habitatN$Habitat %in% c("CL"))
EC <- communityB %>% filter(habitatN$Habitat %in% c("EC"))
JC <- communityB %>% filter(habitatN$Habitat %in% c("JC"))
MF <- communityB %>% filter(habitatN$Habitat %in% c("MF"))
NF <- communityB %>% filter(habitatN$Habitat %in% c("NF"))

# rname <- rownames(BB_t)
cname <- c("BB","CL","EC","JC","MF","NF")
#    Species     chao  chao.se    jack1 jack1.se    jack2     boot  boot.se  n
# BB     125 219.7378 30.74967 189.8889 25.55845 229.6528 153.2380 12.00890  9
# CL     210 333.4333 35.52432 295.8667 26.84043 349.8476 247.2540 12.74553 15
# EC      79 125.0800 18.14375 117.4000 20.40392 137.2000  96.3264  9.65950  5
# JC     103 213.8395 39.07452 162.5556 23.27718 202.4167 128.2358 10.61719  9
# MF     141 285.6838 43.12727 222.7778 32.32856 276.6389 175.8731 14.56185  9
# NF     223 423.0117 49.47008 342.0909 42.99145 420.5545 273.7362 20.08776 11

comm4inext <- matrix(c(colSums(BB), colSums(CL), colSums(EC), colSums(JC), colSums(MF), colSums(NF)), ncol = 6)
# rownames(comm4inext) <- rname
colnames(comm4inext) <- cname
comm4inext <- rbind(c(nrow(BB), nrow(CL), nrow(EC), nrow(JC), nrow(MF), nrow(NF)), comm4inext)
comm4inext
confnum=0.95 # set confidence here
outcomm0 <- iNEXT(comm4inext, q=0, conf=confnum, datatype="incidence_freq")
# Hill numbers:  0 = sp richness, 1 = Shannon, 2 = inverse Simpson
outcomm0$DataInfo
ChaoRichness(comm4inext, datatype="incidence_freq") # same as specpool results, so i trust that we have done this correctly
ChaoShannon(comm4inext, datatype="incidence_freq")

outcomm1 <- iNEXT(comm4inext, q=1, conf=confnum, datatype="incidence_freq")
ggiNEXT(outcomm1, type=1)
outcomm2 <- iNEXT(comm4inext, q=2, conf=confnum, datatype="incidence_freq")
ggiNEXT(outcomm2, type=1)

ggiNEXT(outcomm0, type=1) # sample-size-based rarefaction/extrapolation curve
ggiNEXT(outcomm1, type=1) # sample-size-based rarefaction/extrapolation curve
ggiNEXT(outcomm0, type=2) # sample completeness curve
ggiNEXT(outcomm0, type=3) # coverage-based rarefaction/extrapolation curve

outcomm0$DataInfo
outcomm0$iNextEst
outcomm0$AsyEst
```

```{r iNextPD test, eval=FALSE, include=FALSE}
data(bird) 
str(bird)
bird.lab <- rownames(bird$abun)
bird.phy <- ade4::newick2phylog(bird$tre)
# plot(bird.phy)
table.phylog(bird$abun, bird.phy, csize=4, f.phylog=0.7)
outcommbird <- iNextPD(x=bird$abun, labels=bird.lab, phy=bird.phy, q=0, datatype="abundance")
ggiNEXT(outcommbird, type=1, se=TRUE, facet.var="none", color.var="site", grey=FALSE)
ggiNEXT(outcommbird, type=2, se=TRUE, facet.var="none", color.var="site", grey=FALSE)
ggiNEXT(outcommbird, type=3, se=TRUE, facet.var="none", color.var="site", grey=FALSE)

out <- iNextPD(bird$abun, bird.lab, bird.phy, q=c(0, 1, 2), datatype="abundance", endpoint=400)

# Sample‐size‐based R/E curves, separating by "site""
ggiNEXT(out, type=1, facet.var="site")
# Sample‐size‐based R/E curves, separating by "order"
ggiNEXT(out, type=1, facet.var="order")
# display black‐white theme
ggiNEXT(out, type=1, facet.var="order", grey=TRUE)


# incidence data

bird.lab <- rownames(bird$abun)  # OTU names
bird.phy <- ade4::newick2phylog(bird$tre) # convert newick tree to phylog object
out.inc <- iNextPD(bird$inci, bird.lab, bird.phy, 
                   q=0, datatype="incidence_raw", 
                   endpoint = 25, se=TRUE)

# Sample‐size‐based R/E curves
ggiNEXT(out.inc, type=1, color.var="site") + 
  theme_bw(base_size = 18) + 
  theme(legend.position="none")

ggiNEXT(out.inc, type=2, color.var="site") +
  xlim(c(5,25)) + ylim(c(0.7,1)) +
  theme_bw(base_size = 18) + 
  theme(legend.position="none")

```



## mvabund
Test for significant effects of elevation, forest type, and landsat channels.  Start with a subset of OTUs (n=100) to make things run faster, then when the model is working, run with full database

anova.manyglm options
    *test = "score"* # anova.manyglm help file says that test="wald" is poor for binomial data under some conditions. "score" is the better alternative. 
    *cor.type = "shrink"* # estimates correlations between species, but in an efficient way, which is necessary for our kind of dataset, where there are many more species than there are samples


```{r mvabund explorations}
communityB.mvb <- communityB[ , 1:100] %>% mvabund() # partial dataset for debugging
# communityB.mvb <- communityB %>% mvabund()  # full dataset (runs slowly)
nboot <- 50 # set to 50 for debugging
# nboot <- 999 # set to 999 for publication
# 
habitatN.mvb <- habitatN %>% select(Habitat, weather_value, Elevation_m, x20150401b1m:Simpson_evenness_index)

par(mfrow=c(1,1))
meanvar.plot(communityB.mvb ~ habitatN.mvb$Habitat)
abline(a = 0, b = 1, col = "green")
fct_relevel(habitatN.mvb$Habitat, "MF") # make MF the reference level. doesn't work with summary.manyglm

# test for significance of elevation and forest type
mod1.mvb <- manyglm(communityB.mvb ~ 1, family = binomial("cloglog"))
mod2.mvb <- manyglm(communityB.mvb ~ habitatN.mvb$Elevation_m, family = binomial("cloglog"))
mod3.mvb <- manyglm(communityB.mvb ~ habitatN.mvb$Habitat, family = binomial("cloglog"))
mod4.mvb <- manyglm(communityB.mvb ~ habitatN.mvb$Elevation_m + habitatN.mvb$Habitat, family = binomial("cloglog"))
drop1(mod4.mvb)
mod5.mvb <- manyglm(communityB.mvb ~ habitatN.mvb$Elevation_m * habitatN.mvb$Habitat, family = binomial("cloglog"))
mod6.mvb <- manyglm(communityB.mvb ~ habitatN.mvb$weather_value, family = binomial("cloglog"))
mod7.mvb <- manyglm(communityB.mvb ~ habitatN.mvb$Simpson_evenness_index, family = binomial("cloglog"))
mod8.mvb <- manyglm(communityB.mvb ~ habitatN.mvb$Habitat * habitatN.mvb$Simpson_evenness_index, family = binomial("cloglog"))
plot(mod1.mvb)
plot(mod2.mvb)
plot(mod3.mvb)
plot(mod4.mvb) # the best residuals
plot(mod5.mvb) # good residuals
plot(mod6.mvb)
plot(mod7.mvb)
plot(mod8.mvb)
anova(mod1.mvb, mod2.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # Elevation is significant
anova(mod2.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # Elevation is significant
anova(mod1.mvb, mod3.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # Habitat is significant on its own
anova(mod3.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # Habitat is significant on its own
anova(mod2.mvb, mod4.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # Habitat is significant, even with Elevation present
anova(mod4.mvb, mod5.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # Habitat * Elevation interaction effect is significant (i suspect this is mainly due to CL)
anova(mod5.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # Habitat * Elevation interaction effect is significant (i suspect this is mainly due to CL)
# summary(mod3.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # Habitat is significant on its own
anova(mod6.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot) # weather has a sig effect
anova(mod7.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot) # Simpson_evenness_index has a non-sig effect
anova(mod8.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot) # Habitat * Simpson_evenness_index interaction has a sig effect

```


## calculate conditional and marginal effects of the main predictors
## get a glm fit for a variable to get approx VIF’s
```{r}
ft.glm1 <- glm(communityB.mvb[, 1] ~ ., data = habitatN.mvb[c(1:3,74)], family = binomial)
vif(ft.glm1)
```
                               GVIF Df GVIF^(1/(2*Df))
Habitat                4.433146e+09  5        9.218732
weather_value          4.433146e+09  2      258.034640
Elevation_m            1.077532e+00  1        1.038042
Simpson_evenness_index 1.000000e+00  1        1.000000

These predictors are not strongly correlated, so we can calculate conditional effects

```{r mvabund conditional effects}
mod_cond1.mvb <- manyglm(communityB.mvb ~ ., data = habitatN.mvb[c(1:3,74)], family = binomial("cloglog")) # Habitat, weather_value, Elevation_m, Simpson_evenness_index
plot(mod_cond1.mvb)
summary(mod_cond1.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot) 
```

I think that the p-values don't matter here, just the score value.  Habitat and Elevation are conditionally more important (i.e. when the other predictors are present in the model)
Test statistics:
                       score value Pr(>score)
(Intercept)                 135.29          1
HabitatCL                    62.11          1
HabitatEC                    29.37          1
HabitatJC                    15.18          1
HabitatMF                    12.91          1
HabitatNF                    30.97          1
weather_valuesunny           37.24          1
weather_valuerainy           43.99          1
Elevation_m                 111.20          1
Simpson_evenness_index       65.63          1
Arguments:
 Test statistics calculated assuming correlation matrix shrunk by parameter 0.93 
 P-value calculated using 50 resampling iterations via pit.trap resampling (to account for correlation in testing).

Test statistic:  564.7, p-value: 0.353 

```{r mvabund marginal effects}
habitatN.marg.mvb <- data.frame(habitatN.mvb[c(1:3,74)]) # this can be changed
devs <- rep(NA, ncol(habitatN.marg.mvb))
names(devs) <- colnames(habitatN.marg.mvb)

for (iVar in 1:ncol(habitatN.marg.mvb)) {
    mod_marg.glm <- manyglm(communityB.mvb ~ habitatN.marg.mvb[, iVar], data = habitatN.marg.mvb, family = binomial("cloglog"))
    devs[iVar] <- -2 * sum(logLik(mod_marg.glm))
}

(devs <- devs + 2*sum(logLik(mod_cond1.mvb)))
```

Separately, weather, Elevation, and Simpson_evenness are relatively more important
               Habitat          weather_value            Elevation_m Simpson_evenness_index 
              559.7001               991.6422               967.9322              1118.6665 


Mosaic forest is significantly different from all other habitat types, although 
```{r MF vs BB, CL, EC, JC, NF}
# MF vs BB
communityB_MFBB <- communityB %>% filter(habitatN$Habitat %in% c("BB", "MF"))
habitatN_MFBB <- data.frame(habitatN.mvb[c(1:3,74)]) %>% filter(habitatN$Habitat %in% c("BB", "MF")) # predictors can be changed
habitatN_MFBB <- droplevels(habitatN_MFBB)
communityB_MFBB.mvb <- communityB_MFBB[ , 1:350] %>% mvabund() # partial dataset for debugging
# communityB_MFBB.mvb <- communityB_MFBB %>% mvabund() # full dataset
nboot <- 100 # set to 100 for debugging
# nboot <- 999 # set to 999 for publication

modMFBB1.mvb <- manyglm(communityB_MFBB.mvb ~ Habitat, data = habitatN_MFBB, family = binomial("cloglog"))
plot(modMFBB1.mvb)
anova(modMFBB1.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # BB is sig diff from MF

# MF vs CL
communityB_MFCL <- communityB %>% filter(habitatN$Habitat %in% c("CL", "MF"))
habitatN_MFCL <- data.frame(habitatN.mvb[c(1:3,74)]) %>% filter(habitatN$Habitat %in% c("CL", "MF")) # predictors can be changed
habitatN_MFCL <- droplevels(habitatN_MFCL)
communityB_MFCL.mvb <- communityB_MFCL[ , 1:350] %>% mvabund() # partial dataset for debugging
# communityB_MFCL.mvb <- communityB_MFCL %>% mvabund() # full dataset
nboot <- 100 # set to 100 for debugging
# nboot <- 999 # set to 999 for publication

modMFCL1.mvb <- manyglm(communityB_MFCL.mvb ~ Habitat, data = habitatN_MFCL, family = binomial("cloglog"))
plot(modMFCL1.mvb)
anova(modMFCL1.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # CL is sig diff from MF


# MF vs EC
communityB_MFEC <- communityB %>% filter(habitatN$Habitat %in% c("EC", "MF"))
habitatN_MFEC <- data.frame(habitatN.mvb[c(1:3,74)]) %>% filter(habitatN$Habitat %in% c("EC", "MF")) # predictors can be changed
habitatN_MFEC <- droplevels(habitatN_MFEC)
communityB_MFEC.mvb <- communityB_MFEC[ , 1:350] %>% mvabund() # partial dataset for debugging
# communityB_MFEC.mvb <- communityB_MFEC %>% mvabund() # full dataset
nboot <- 100 # set to 100 for debugging
# nboot <- 999 # set to 999 for publication

modMFEC1.mvb <- manyglm(communityB_MFEC.mvb ~ Habitat, data = habitatN_MFEC, family = binomial("cloglog"))
plot(modMFEC1.mvb)
anova(modMFEC1.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  
# EC is sig diff from MF


# MF vs JC
communityB_MFJC <- communityB %>% filter(habitatN$Habitat %in% c("JC", "MF"))
habitatN_MFJC <- data.frame(habitatN.mvb[c(1:3,74)]) %>% filter(habitatN$Habitat %in% c("JC", "MF")) # predictors can be changed
habitatN_MFJC <- droplevels(habitatN_MFJC)
communityB_MFJC.mvb <- communityB_MFJC[ , 1:350] %>% mvabund() # partial dataset for debugging
# communityB_MFJC.mvb <- communityB_MFJC %>% mvabund() # full dataset
nboot <- 100 # set to 100 for debugging
# nboot <- 999 # set to 999 for publication

modMFJC1.mvb <- manyglm(communityB_MFJC.mvb ~ Habitat, data = habitatN_MFJC, family = binomial("cloglog"))
plot(modMFJC1.mvb)
anova(modMFJC1.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # JC is sig diff from MF


# MF vs NF  ## Using the full community (746 OTUs and nBoot=999)
communityB_MFNF <- communityB %>% filter(habitatN$Habitat %in% c("NF", "MF"))
habitatN_MFNF <- data.frame(habitatN.mvb[c(1:3,74)]) %>% filter(habitatN$Habitat %in% c("NF", "MF")) # predictors can be changed
habitatN_MFNF <- droplevels(habitatN_MFNF)
# communityB_MFNF.mvb <- communityB_MFNF[ , 1:350] %>% mvabund() # partial dataset for debugging
communityB_MFNF.mvb <- communityB_MFNF %>% mvabund() # full dataset
nboot <- 100 # set to 100 for debugging
# nboot <- 999 # set to 999 for publication

modMFNF1.mvb <- manyglm(communityB_MFNF.mvb ~ Habitat, data = habitatN_MFNF, family = binomial("cloglog"))
plot(modMFNF1.mvb)
anova(modMFNF1.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  
# See results below for detail.  MF and NF sig diff at p=0.008 level 
```

```
> anova(modMFNF1.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = 999)  

Time elapsed: 0 hr 15 min 33 sec
Analysis of Variance Table

Model: manyglm(formula = communityB_MFNF.mvb ~ Habitat, family = binomial("cloglog"), 
Model:     data = habitatN_MFNF)

Multivariate test:
            Res.Df Df.diff score Pr(>score)   
(Intercept)     21                            
Habitat         20       1   126      0.008 **
 ---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
Arguments:
 Test statistics calculated assuming correlated response via ridge regularization 
 P-value calculated using 999 resampling iterations via PIT-trap resampling (to account for correlation in testing).
```


Natural forest is significantly different from BB, CL, EC, and JC
```{r NF vs BB, CL, EC, JC}
# NF vs BB
communityB_NFBB <- communityB %>% filter(habitatN$Habitat %in% c("BB", "NF"))
habitatN_NFBB <- data.frame(habitatN.mvb[c(1:3,74)]) %>% filter(habitatN$Habitat %in% c("BB", "NF")) # predictors can be changed
habitatN_NFBB <- droplevels(habitatN_NFBB)
communityB_NFBB.mvb <- communityB_NFBB[ , 1:350] %>% mvabund() # partial dataset for debugging
# communityB_NFBB.mvb <- communityB_NFBB %>% mvabund() # full dataset
nboot <- 100 # set to 100 for debugging
# nboot <- 999 # set to 999 for publication

modNFBB1.mvb <- manyglm(communityB_NFBB.mvb ~ Habitat, data = habitatN_NFBB, family = binomial("cloglog"))
plot(modNFBB1.mvb)
anova(modNFBB1.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # BB is sig diff from NF

# NF vs CL
communityB_NFCL <- communityB %>% filter(habitatN$Habitat %in% c("CL", "NF"))
habitatN_NFCL <- data.frame(habitatN.mvb[c(1:3,74)]) %>% filter(habitatN$Habitat %in% c("CL", "NF")) # predictors can be changed
habitatN_NFCL <- droplevels(habitatN_NFCL)
communityB_NFCL.mvb <- communityB_NFCL[ , 1:350] %>% mvabund() # partial dataset for debugging
# communityB_NFCL.mvb <- communityB_NFCL %>% mvabund() # full dataset
nboot <- 100 # set to 100 for debugging
# nboot <- 999 # set to 999 for publication

modNFCL1.mvb <- manyglm(communityB_NFCL.mvb ~ Habitat, data = habitatN_NFCL, family = binomial("cloglog"))
plot(modNFCL1.mvb)
anova(modNFCL1.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # CL is sig diff from NF


# NF vs EC
communityB_NFEC <- communityB %>% filter(habitatN$Habitat %in% c("EC", "NF"))
habitatN_NFEC <- data.frame(habitatN.mvb[c(1:3,74)]) %>% filter(habitatN$Habitat %in% c("EC", "NF")) # predictors can be changed
habitatN_NFEC <- droplevels(habitatN_NFEC)
communityB_NFEC.mvb <- communityB_NFEC[ , 1:350] %>% mvabund() # partial dataset for debugging
# communityB_NFEC.mvb <- communityB_NFEC %>% mvabund() # full dataset
nboot <- 100 # set to 100 for debugging
# nboot <- 999 # set to 999 for publication

modNFEC1.mvb <- manyglm(communityB_NFEC.mvb ~ Habitat, data = habitatN_NFEC, family = binomial("cloglog"))
plot(modNFEC1.mvb)
anova(modNFEC1.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  
# EC is sig diff from NF


# NF vs JC
communityB_NFJC <- communityB %>% filter(habitatN$Habitat %in% c("JC", "NF"))
habitatN_NFJC <- data.frame(habitatN.mvb[c(1:3,74)]) %>% filter(habitatN$Habitat %in% c("JC", "NF")) # predictors can be changed
habitatN_NFJC <- droplevels(habitatN_NFJC)
communityB_NFJC.mvb <- communityB_NFJC[ , 1:350] %>% mvabund() # partial dataset for debugging
# communityB_NFJC.mvb <- communityB_NFJC %>% mvabund() # full dataset
nboot <- 100 # set to 100 for debugging
# nboot <- 999 # set to 999 for publication

modNFJC1.mvb <- manyglm(communityB_NFJC.mvb ~ Habitat, data = habitatN_NFJC, family = binomial("cloglog"))
plot(modNFJC1.mvb)
anova(modNFJC1.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # JC is sig diff from NF

```


Trying another way to test for sig difference between forests. Create a forest-only dataset, then test for a habitat effect with increasingly collapsed levels, testing for sig differences between nested models. Outcome:  a model with MF and NF combined into one level is not sig different from one with MF and NF separate.  But all other forest types (EC, JC, BB) are sig different from the MFNF level. 
```{r}
# MF vs BB
communityB_forest <- communityB %>% filter(!(habitatN$Habitat %in% c("CL")))
habitatN_forest <- data.frame(habitatN.mvb[c(1:3,74)]) %>% filter(!(habitatN$Habitat %in% c("CL"))) # predictors can be changed
habitatN_forest <- droplevels(habitatN_forest)
communityB_forest.mvb <- communityB_forest[ , 1:150] %>% mvabund() # partial dataset for debugging
communityB_forest.mvb <- communityB_forest.mvb %>% mvabund() # full dataset
nboot <- 100 # set to 100 for debugging
# nboot <- 999 # set to 999 for publication

mod_forest_BBECJCMFNF.mvb <- manyglm(communityB_forest.mvb ~ Habitat, data = habitatN_forest, family = binomial("cloglog"))
plot(mod_forest_BBECJCMFNF.mvb)
anova(mod_forest_BBECJCMFNF.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = nboot)  # p = 0.01 for nBoot = 100

# combine MF and NF
habitatN_forest$HabitatMFNF <- fct_collapse(habitatN_forest$Habitat, MFNF = c("MF", "NF"))
fct_count(habitatN_forest$HabitatMFNF)

mod_forest_BBECJC_MFNF.mvb <- manyglm(communityB_forest.mvb ~ HabitatMFNF, data = habitatN_forest, family = binomial("cloglog"))
plot(mod_forest_BBECJC_MFNF.mvb)
anova(mod_forest_BBECJCMFNF.mvb, mod_forest_BBECJC_MFNF.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = 299)  # no sig diff btw the two models (p=0.087 with nBoot = 299 and all 746 OTUs). Suggests weak or no diff btw MF and NF, which is reasonable.

# combine MF, NF, and BB
habitatN_forest$HabitatMFNFBB <- fct_collapse(habitatN_forest$HabitatMFNF, MFNFBB = c("MFNF", "BB"))
fct_count(habitatN_forest$HabitatMFNFBB)

mod_forest_ECJC_BBMFNF.mvb <- manyglm(communityB_forest.mvb ~ HabitatMFNFBB, data = habitatN_forest, family = binomial("cloglog"))
plot(mod_forest_ECJC_BBMFNF.mvb)
anova(mod_forest_BBECJC_MFNF.mvb, mod_forest_ECJC_BBMFNF.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = 299)  # sig diff btw the two models (p=0.017 with nBoot = 299 and all 746 OTUs), so do not combine BB with MFNF

# combine MF, NF, and JC
habitatN_forest$HabitatMFNFJC <- fct_collapse(habitatN_forest$HabitatMFNF, MFNFJC = c("MFNF", "JC"))
fct_count(habitatN_forest$HabitatMFNFJC)

mod_forest_ECBB_MFNFJC.mvb <- manyglm(communityB_forest.mvb ~ HabitatMFNFJC, data = habitatN_forest, family = binomial("cloglog"))
plot(mod_forest_ECBB_MFNFJC.mvb)
anova(mod_forest_BBECJC_MFNF.mvb, mod_forest_ECBB_MFNFJC.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = 299)  # sig diff btw the two models (p=0.003 with nBoot = 299 and all 746 OTUs). so do not combine JC with MFNF

# combine MF, NF, and EC
habitatN_forest$HabitatMFNFEC <- fct_collapse(habitatN_forest$HabitatMFNF, MFNFEC = c("MFNF", "EC"))
fct_count(habitatN_forest$HabitatMFNFEC)

mod_forest_BBJC_MFNFEC.mvb <- manyglm(communityB_forest.mvb ~ HabitatMFNFEC, data = habitatN_forest, family = binomial("cloglog"))
plot(mod_forest_BBJC_MFNFEC.mvb)
anova(mod_forest_BBECJC_MFNF.mvb, mod_forest_BBJC_MFNFEC.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = 299)  # sig diff btw the two models (p=0.003 with nBoot = 299 and all 746 OTUs). so do not combine EC with MFNF. Use habitatN$HabitatMFNF as the forest predictor



# now add the other predictors
mod_forest_all4.mvb <- manyglm(communityB_forest.mvb ~ HabitatMFNF + Elevation_m + weather_value + Simpson_evenness_index, data = habitatN_forest, family = binomial("cloglog"))
plot(mod_forest_all4.mvb)
anova(mod_forest_all4.mvb, cor.type = "shrink", test = "score", show.time = "all", nBoot = 299)  # HabitatMFNF, Elevation_m, and weather_value are all highly significant (all 746 OTUs).  Simpson evenness index is not sig

```

```
Time elapsed: 0 hr 4 min 47 sec
Analysis of Variance Table

Model: manyglm(formula = communityB_forest.mvb ~ HabitatMFNF + Elevation_m + weather_value + Simpson_evenness_index, family = binomial("cloglog"), data = habitatN_forest)

Multivariate test:
                       Res.Df Df.diff  score Pr(>score)   
(Intercept)                48                             
HabitatMFNF                45       3 263.05      0.003 **
Elevation_m                44       1  93.46      0.003 **
weather_value              42       2 152.86      0.003 **
Simpson_evenness_index     41       1  49.67      0.333   
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
Arguments:
 Test statistics calculated assuming correlated response via ridge regularization 
 P-value calculated using 299 resampling iterations via PIT-trap resampling (to account for correlation in testing).
```




# SpeciesMix.  I cannot get this to run
SpeciesMix(sp.form, sp.data, covar.data, G=2, pars=NA, em.prefit=TRUE, em.steps=3, em.refit = 1, dist="bernoulli" , est.var = FALSE,residuals=FALSE,trace=TRUE)
```{r SpeciesMix spider exampl}
data(spider)
str(spider$abund)
# all abundance variables are integers. SpeciesMix needs them to be numeric :(
for(iVar in 1:ncol(spider$abund))
  spider$abund[,iVar] = as.numeric(spider$abund[,iVar])
str(spider$abund)
library(SpeciesMix)
ft.Mix2 = SpeciesMix(abund~soil.dry+moss+fallen.leaves+herb.layer,
                       spider$abund,spider$x,dist="negbin",G=2)
ft.Mix2
ft.Mix2$coef
ft.Mix2$tau
ft.Mix2$sp.intercept
names(ft.Mix2)

```

This does not run
```{r, eval=FALSE}
communityB_SM <- communityB[ , 1:100]
str(communityB_SM) # all numeric
ft.MixG2 = SpeciesMix(communityB_SM ~ Habitat + weather_value + Elevation_m, communityB_SM, habitatN, dist = "bernoulli", G = 2)

```




boral:  Testing different error families.  Decided on family = "binomial" and row.effect = "random".  Do not run this chunk
```{r boral, cache=TRUE, eval=FALSE, include=FALSE}
mcmc.control <- list(n.burnin = 300, n.iteration = 3000, n.thin = 30)

# colnames(community) <- c(1:443)
# colnames(communityB) <- c(1:443)

#### Negative binomial 
comm.fit.nb3 <- boral(community, family = "negative.binomial", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control) 
latvarscomm.fit.nb3 <- comm.fit.nb3[["lv.median"]]
summary(comm.fit.nb3)
par(mfrow = c(2,2))
plot(comm.fit.nb3) ## Plots used in residual analysis, 
par(mfrow = c(1,1))

# par(mfrow = c(1,2))
lvsplot(comm.fit.nb3, biplot=FALSE, col=as.numeric(habitatN$Habitat))
# plot(lv2 ~ lv1, data = latvarscomm.fit.nb3, col=as.numeric(habitatN$Habitat))
# par(mfrow = c(1,1))

commB.fit.nb3 <- boral(communityB, family = "negative.binomial", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
summary(commB.fit.nb3)
par(mfrow = c(2,2))
plot(commB.fit.nb3) ## Plots used in residual analysis, 
par(mfrow = c(1,1))
lvsplot(commB.fit.nb3, biplot=FALSE)

#### Poisson
commB.fit.pb3 <- boral(communityB, family = "poisson", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
summary(commB.fit.pb3)
par(mfrow = c(2,2))
plot(commB.fit.pb3) ## Plots used in residual analysis, 
par(mfrow = c(1,1))
lvsplot(commB.fit.pb3, biplot=FALSE)

#### Binomial
commB.fit.b3 <- boral(communityB, family = "binomial", num.lv = 2, row.eff = "random", mcmc.control = mcmc.control) # row.eff = "random" makes this a compositional model (ignores differences in overall abundance across samples, which might help control for weather effects)
summary(commB.fit.b3)
par(mfrow = c(2,2))
plot(commB.fit.b3) ## Plots used in residual analysis, 
par(mfrow = c(1,1))
lvsplot(commB.fit.b3, biplot=FALSE, col = as.numeric(habitatN$Habitat))

# #### Ordinal  # does not run, even overnight
# communityO <- community+1
# comm.fit.o3 <- boral(communityO, family = "ordinal", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
# summary(comm.fit.o3)
# par(mfrow = c(2,2))
# plot(comm.fit.o3) ## Plots used in residual analysis, 
# par(mfrow = c(1,1))
# lvsplot(comm.fit.o3, biplot=FALSE)
```

Poisson and Binomial to produce the best residuals. I re-ran with more iterations, and Binomial had the best (slightly) residuals.  So i have settled on Binomial, which is expected.
```{r boral high iterations, eval=FALSE}

# colnames(community) <- c(1:443)  
# colnames(communityB) <- c(1:443)

# mcmc.control4 <- list(n.burnin = 10000, n.iteration = 40000, n.thin = 30, seed = 123)
mcmc.control4 <- list(n.burnin = 10000, n.iteration = 40000, n.thin = 30)

# #### Poisson
# commB.fit.pb3.4 <- boral(communityB, family = "poisson", num.lv = 3, row.eff = "fixed", mcmc.control = mcmc.control4, save.model = TRUE)  # high iterations 
# summary(commB.fit.pb3.4) 
# par(mfrow = c(2,2))
# plot(commB.fit.pb3.4) ## Plots used in residual analysis, 
# par(mfrow = c(1,1))
# mypalette <- brewer.pal(6, "Dark2")
# par(mfrow = c(1,2))
# lvsplot(commB.fit.pb3.4, col = as.numeric(habitatN$Habitat), pch = 16) # ind.spp = 5:  show top 5 most important indicator species
# plot(commB.fit.pb3.4[["lv.median"]][,1] ~ commB.fit.pb3.4[["lv.median"]][,2], col = as.numeric(habitatN$Habitat), pch = 16)  # to get just points, which we can then format as we want
# par(mfrow = c(1,1))
# # saveRDS(commB.fit.pb3.4, "commB.fit.pb3.4.RDS")

#### Binomial
commB.fit.b3.4.none <- boral(communityB, family = "binomial", num.lv = 2, row.eff = "none", mcmc.control = mcmc.control4, save.model = TRUE)
summary(commB.fit.b3.4)
par(mfrow = c(2,2))
plot(commB.fit.b3.4) ## Plots used in residual analysis, 
par(mfrow = c(1,1))
par(mfrow = c(1,2))
lvsplot(commB.fit.b3.4, biplot=FALSE, col = as.numeric(habitatN$Habitat))
plot(commB.fit.b3.4[["lv.median"]][,2] ~ commB.fit.b3.4[["lv.median"]][,1], col = as.numeric(habitatN$Habitat), pch = 16)  # to get just points, which we can then format as we want
par(mfrow = c(1,1))
saveRDS(commB.fit.b3.4, "analysis/commB.fit.b3.4.RDS")

# commB.fit.b3.4 <- readRDS("commB.fit.b3.4.RDS")
```



## START HERE:  Do constrained ordination with ssvs.index and calculate variance explained

Constrained ordination
```{r constrained boral ordination,}
#### Binomial 
mcmc.control <- list(n.burnin = 300, n.iteration = 3000, n.thin = 30)

X <- scale(habitatN$Elevation_m, scale = FALSE)

commB.fit.b3.X <- boral(communityB, X = X, family = "binomial", num.lv = 2, row.eff = "random", mcmc.control = mcmc.control, calc.ics = TRUE, save.model = TRUE)

summary(commB.fit.b3.X)

par(mfrow = c(2,2))
plot(commB.fit.b3.X) ## Plots used in residual analysis, 
par(mfrow = c(1,1))

# latent variables plot
lvsplot(commB.fit.b3.X, biplot=FALSE, col = as.numeric(habitatN$Habitat))
commB.fit.b3.X.biplot <- lvsplot(commB.fit.b3.X, ind.spp=10, return.vals=TRUE)


# DIY slightly fancier biplot
par(mfrow=c(1,1))
plot(commB.fit.b3.X.biplot$scaled.lvs,col=as.numeric(habitatN$Habitat),type="n",ylim=c(-2.1,1))
text(commB.fit.b3.X.biplot$scaled.lvs[,1],commB.fit.b3.X.biplot$scaled.lvs[,2],rownames(communityB),
     col=as.numeric(habitatN$Habitat),cex=0.75)
arrows(0,0,commB.fit.b3.X.biplot$scaled.lv.coefs[,1],commB.fit.b3.X.biplot$scaled.lv.coefs[,2],
       length=0.07,lwd=0.5)
text(commB.fit.b3.X.biplot$scaled.lv.coefs[,1],commB.fit.b3.X.biplot$scaled.lv.coefs[,2],colnames(communityB),
     cex=0.35)
# I have too many arrows - should only choose the rows of $scaled.lv.coefs for the
# important Orders (maybe just do the significant ones from manyglm???)

# how do the ordination scores relate to treatment effect?
cbind(commB.fit.b3.X.biplot$scaled.lvs,habitatN$Habitat)
par(mfrow = c(1,2))
plot(commB.fit.b3.X.biplot$scaled.lvs[,1]~habitatN$Habitat)
plot(commB.fit.b3.X.biplot$scaled.lvs[,2]~habitatN$Habitat)
par(mfrow = c(1,1))
cor(commB.fit.b3.X.biplot$scaled.lvs, as.numeric(habitatN$Habitat))
# could even put a big arrow on the biplot in the direction of correlation


library(corrplot) ## For plotting correlations
communityB.ord = boral(communityB, num.lv=2, family="negative.binomial", save.model=TRUE, row.eff="random", calc.ics = TRUE, mcmc.control = mcmc.control)
res.cors <- get.residual.cor(communityB.ord)
# saveRDS(communityB.ord, "analysis/communityB.ord.RDS")
corrplot(res.cors$cor, title = "Residual correlations", type = "lower", diag = FALSE, mar = c(3,0.5,2,1), tl.srt = 45)
summary(communityB.ord)


communityB.partialOrd = boral(communityB, X = X, num.lv = 2, family = "negative.binomial", save.model = TRUE, row.eff = "random", calc.ics = TRUE, mcmc.control = mcmc.control)

partRes.cors <- get.residual.cor(communityB.partialOrd)
par(mfrow=c(1,2))
corrplot(res.cors$cor, title = "Residual correlations",
         type = "lower", diag = FALSE, mar = c(3,0.5,2,1), tl.srt = 45)
corrplot(partRes.cors$cor, title = "Partial residual correlations",
         type = "lower", diag = FALSE, mar = c(3,0.5,2,1), tl.srt = 45)

summary(communityB.ord)$ics
summary(communityB.partialOrd)$ics
res.cors$trace
partRes.cors$trace
(res.cors$trace-partRes.cors$trace)/res.cors$trace
```






```{r betapart}
communityBbetapart <- bind_cols(habitatN, communityB)
communityBbetapart <- communityBbetapart %>% select(-c(Habitat:sprichness))

JCNF <- communityBbetapart %>% filter(habitatN$Habitat %in% c("JC", "NF")) %>% column_to_rownames(var="Site")
BBNF <- communityBbetapart %>% filter(habitatN$Habitat %in% c("BB", "NF")) %>% column_to_rownames(var="Site")
CLNF <- communityBbetapart %>% filter(habitatN$Habitat %in% c("CL", "NF")) %>% column_to_rownames(var="Site")
ECNF <- communityBbetapart %>% filter(habitatN$Habitat %in% c("EC", "NF")) %>% column_to_rownames(var="Site")
MFNF <- communityBbetapart %>% filter(habitatN$Habitat %in% c("MF", "NF")) %>% column_to_rownames(var="Site")

JCNF.multi.dist <- beta.multi(JCNF, index.family="jac")
BBNF.multi.dist <- beta.multi(BBNF, index.family="jac")
CLNF.multi.dist <- beta.multi(CLNF, index.family="jac")
ECNF.multi.dist <- beta.multi(ECNF, index.family="jac")
MFNF.multi.dist <- beta.multi(MFNF, index.family="jac")

multi.all <- list(JCNF = JCNF.multi.dist, BBNF = BBNF.multi.dist, CLNF = CLNF.multi.dist, ECNF =  ECNF.multi.dist, MFNF = MFNF.multi.dist)


ALL.dist <- communityBbetapart %>% column_to_rownames(var="Site") %>% beta.pair(index.family="jac")
ALL.dist.subset <- ALL.dist[["beta.jne"]]
ALL.dist.jne.jmds <- metaMDS(ALL.dist.subset)
ALL.dist.jne.jmds <- metaMDS(ALL.dist.subset, previous.best = ALL.dist.jne.jmds)
stressplot(ALL.dist.jne.jmds)
ALL.dist.subset <- ALL.dist[["beta.jtu"]]
ALL.dist.jtu.jmds <- metaMDS(ALL.dist.subset)
ALL.dist.jtu.jmds <- metaMDS(ALL.dist.subset, previous.best = ALL.dist.jne.jmds)
stressplot(ALL.dist.jtu.jmds)



par(mfrow=c(2,2))
with(habitatN, ordisurf(community.jmds, sprichness, main="All beta diversity", cex=0.5, col = "white", ylim = c(-0.5, 0.5), xlim = c(-0.4, 0.4)))
# plot(community.jmds, main = "All beta diversity", ylim = c(-0.4, 0.4))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[1]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))

plot(ALL.dist.jtu.jmds, main = "Turnover beta diversity only", ylim = c(-0.5, 0.5), xlim = c(-0.4, 0.4))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[1]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
    
plot(ALL.dist.jne.jmds, main = "Nestedness beta diversity only", ylim = c(-0.5, 0.5), xlim = c(-0.4, 0.4))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[1]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
    
par(mfrow=c(1,1))

```



## Forest only analysis
Redoing the above with forest plots only
```{r}
communityBforest <- communityB %>% filter(!(habitatN$Habitat %in% c("CL")))
communityBforest.jmds <- metaMDS(communityBforest, distance = "jaccard", trymax = 40, binary=TRUE)
communityBforest.jmds <- metaMDS(communityBforest, distance = "jaccard", binary = TRUE, previous.best = community.jmds)
stressplot(communityBforest.jmds)
plot(communityBforest.jmds)
habitatNforest <- habitatN %>% filter(!(Habitat %in% c("CL")))
habitatNforest <- droplevels(habitatNforest)
levels(habitatNforest$Habitat)


with(habitatNforest, ordisurf(communityBforest.jmds, sprichness, main="All beta diversity. Forest only", cex=0.5, col = "grey"))
    with(habitatNforest, ordispider(communityBforest.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
    with(habitatNforest, ordispider(communityBforest.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
    with(habitatNforest, ordispider(communityBforest.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
    with(habitatNforest, ordispider(communityBforest.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
    with(habitatNforest, ordispider(communityBforest.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
    
    
    
tabasco(communityBforest, use = communityBforest.jmds, labCol = habitatNforest$Habitat, col = heat.colors(1))



communityBbetapart <- bind_cols(habitatNforest, communityBforest)
communityBbetapart <- communityBbetapart %>% select(-c(Habitat:sprichness))
# 
JCNF <- communityBbetapart %>% filter(habitatNforest$Habitat %in% c("JC", "NF")) %>% column_to_rownames(var="Site")
BBNF <- communityBbetapart %>% filter(habitatNforest$Habitat %in% c("BB", "NF")) %>% column_to_rownames(var="Site")
ECNF <- communityBbetapart %>% filter(habitatNforest$Habitat %in% c("EC", "NF")) %>% column_to_rownames(var="Site")
MFNF <- communityBbetapart %>% filter(habitatNforest$Habitat %in% c("MF", "NF")) %>% column_to_rownames(var="Site")

JCNF.multi.dist <- beta.multi(JCNF, index.family="jac")
BBNF.multi.dist <- beta.multi(BBNF, index.family="jac")
ECNF.multi.dist <- beta.multi(ECNF, index.family="jac")
MFNF.multi.dist <- beta.multi(MFNF, index.family="jac")

multi.NF.all <- list(JCNF = JCNF.multi.dist, BBNF = BBNF.multi.dist, ECNF =  ECNF.multi.dist, MFNF = MFNF.multi.dist)

# comparing to MF
JCMF <- communityBbetapart %>% filter(habitatNforest$Habitat %in% c("JC", "MF")) %>% column_to_rownames(var="Site")
BBMF <- communityBbetapart %>% filter(habitatNforest$Habitat %in% c("BB", "MF")) %>% column_to_rownames(var="Site")
ECMF <- communityBbetapart %>% filter(habitatNforest$Habitat %in% c("EC", "MF")) %>% column_to_rownames(var="Site")

JCMF.multi.dist <- beta.multi(JCMF, index.family="jac")
BBMF.multi.dist <- beta.multi(BBMF, index.family="jac")
ECMF.multi.dist <- beta.multi(ECMF, index.family="jac")

multi.MF.all <- list(JCMF = JCMF.multi.dist, BBMF = BBMF.multi.dist, ECMF =  ECMF.multi.dist)



ALL.dist <- communityBbetapart %>% column_to_rownames(var="Site") %>% beta.pair(index.family="jac")
ALL.dist.subset <- ALL.dist[["beta.jne"]]
ALL.dist.jne.jmds <- metaMDS(ALL.dist.subset)
ALL.dist.jne.jmds <- metaMDS(ALL.dist.subset, previous.best = ALL.dist.jne.jmds)
stressplot(ALL.dist.jne.jmds)
ALL.dist.subset <- ALL.dist[["beta.jtu"]]
ALL.dist.jtu.jmds <- metaMDS(ALL.dist.subset)
ALL.dist.jtu.jmds <- metaMDS(ALL.dist.subset, previous.best = ALL.dist.jne.jmds)
stressplot(ALL.dist.jtu.jmds)


community.jmds <- communityBforest.jmds
habitatN <- habitatNforest

par(mfrow=c(2,2))
with(habitatN, ordisurf(community.jmds, sprichness, main="All beta diversity", cex=0.5, col = "white", ylim = c(-0.8, 0.8), xlim = c(-0.4, 0.4)))
# plot(community.jmds, main = "All beta diversity", ylim = c(-0.4, 0.4))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))

plot(ALL.dist.jtu.jmds, main = "Turnover beta diversity only", ylim = c(-0.8, 0.8), xlim = c(-0.4, 0.4))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
    
plot(ALL.dist.jne.jmds, main = "Nestedness beta diversity only", ylim = c(-0.8, 0.8), xlim = c(-0.4, 0.4))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
    
par(mfrow=c(1,1))
```

```{r}
protest(communityBforest.jmds, ALL.dist.jtu.jmds)
```

Call:
protest(X = communityBforest.jmds, Y = ALL.dist.jtu.jmds) 

Procrustes Sum of Squares (m12 squared):        0.3852 
Correlation in a symmetric Procrustes rotation: 0.7841 
Significance:  0.001 

Permutation: free
Number of permutations: 999

```{r}
protest(communityBforest.jmds, ALL.dist.jne.jmds)
```

Call:
protest(X = communityBforest.jmds, Y = ALL.dist.jne.jmds) 

Procrustes Sum of Squares (m12 squared):        0.9699 
Correlation in a symmetric Procrustes rotation: 0.1736 
Significance:  0.506 

Permutation: free
Number of permutations: 999

```{r boral forest only}
mcmc.control <- list(n.burnin = 10000, n.iteration = 40000, n.thin = 30)
mcmc.control <- list(n.burnin = 300, n.iteration = 3000, n.thin = 30)

#### Binomial
commB.forest.fit.b3.4.fixed <- boral(communityBforest, family = "binomial", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control, save.model = TRUE)
summary(commB.forest.fit.b3.4.fixed)
par(mfrow = c(2,2))
plot(commB.forest.fit.b3.4.fixed) ## Plots used in residual analysis, 
par(mfrow = c(1,1))
par(mfrow = c(1,2))
lvsplot(commB.forest.fit.b3.4.fixed, biplot=FALSE, col = as.numeric(habitatNforest$Habitat))
plot(commB.forest.fit.b3.4.fixed[["lv.median"]][,2] ~ commB.forest.fit.b3.4.fixed[["lv.median"]][,1], col = as.numeric(habitatNforest$Habitat), pch = 16)  # to get just points, which we can then format as we want
par(mfrow = c(1,1))
saveRDS(commB.forest.fit.b3.4.fixed, "analysis/commB.forest.fit.b3.4.fixed.RDS")
```


____________________________________
Ignore all code below this line
____________________________________

We used this code chunk to filter out small OTUs, leaving behind 746 OTUs. We don't need to run this code chunk because we've already done this and created the OTU table that we imported above.
```{r phyloseq filtering, eval=FALSE, include=FALSE}
# no longer need to run this code chunk because we have already used phyloseq to filter out small OTUs
# gsub("[[:punct:][:space:]]", "-", Sys.time()) #time will be shown
# source("https://bioconductor.org/biocLite.R") # to install phyloseq package
# biocLite("phyloseq")
library("phyloseq"); packageVersion("phyloseq")
library("data.table"); packageVersion("data.table")
library("ggplot2"); packageVersion("ggplot2")

TotalCounts <- c(colSums(communityAll))

tdt = data.table(colnames(communityAll),TotalCounts = colSums(communityAll),OTU = colnames(communityAll))

ggplot(tdt, aes(TotalCounts)) +  # histogram
  geom_histogram() + 
  ggtitle("Histogram of Total Counts")

taxcumsum = tdt[, .N, by = TotalCounts]
setkey(taxcumsum, TotalCounts)
taxcumsum[, CumSum := cumsum(N)]
# Define the plot
pCumSum = ggplot(taxcumsum, aes(TotalCounts, CumSum)) + 
  geom_point() +
  xlab("Filtering Threshold, Minimum Total Counts") +
  ylab("OTUs Filtered") +
  ggtitle("OTUs that would be filtered vs. the minimum count threshold")
pCumSum
pCumSum + xlim(0, 100)
pCumSum + xlim(0, 200)
pCumSum + xlim(0, 300)
pCumSum + xlim(0, 400)
pCumSum + xlim(0, 600)
pCumSum + xlim(0, 800)
pCumSum + xlim(0, 2000)
pCumSum + xlim(0, 20000)

## phyloseq-class experiment-level object
## otu_table()   OTU Table:         [ 3426 taxa and 34 samples ]
## sample_data() Sample Data:       [ 34 samples by 11 sample variables ]
## tax_table()   Taxonomy Table:    [ 3426 taxa by 7 taxonomic ranks ]
## phy_tree()    Phylogenetic Tree: [ 3426 tips and 3424 internal nodes ]

## from above result, we decide to use 2 thresholds to filter those small otus: 120 (>=120) and 40 (>=40)
## 40 gives us a table with 443 OTUs. This is the table that we are already reading. 
commMBC.120 <- communityAll[ ,colSums(communityAll)>=120] ## 336 otus remain
commMBC.120 <- commMBC.120[ rowSums(commMBC.120)>0,]
rowSums(commMBC.120)
commMBC.120 <- commMBC.120[-38,] #number 38 site has very few otu and reads number

commMBC.40 <- communityAll[ ,colSums(communityAll)>=40] ## 448 otus remain
commMBC.40 <- commMBC.40[ rowSums(commMBC.40)>0,]
rowSums(commMBC.40)
commMBC.40 <- commMBC.40[-38,]
colnames(commMBC.40)

```


```{r betapart cerambycid example, eval=FALSE}
# Read the data for Northern and Southern European cerambycids
data(ceram.s)
data(ceram.n)

ceram.dist<-beta.pair(ceram.s, index.family="jac")
ceram.beta<-beta.multi(ceram.s, index.family="sor")

# Resample 100 times the multiple-site dissimilarities
# for 10 countries.
beta.ceram.s<-beta.sample(ceram.s, index.family="sor", sites=10, samples=100)
beta.ceram.n<-beta.sample(ceram.n, index.family="sor", sites=10, samples=100)

# Plot the distributions of beta.SIM in Southern Europe (red) 
# and Northern Europe (blue)
plot(density(beta.ceram.s$sampled.values$beta.SIM), col="red", xlim=c(0,1))
lines(density(beta.ceram.n$sampled.values$beta.SIM), col="blue")

# Compute the p-value of difference in beta.SIM between South and North 
# (i.e. the probability of finding in the North a higher value than 
# in the South)
p.value.beta.SIM<-length(which(beta.ceram.s$sampled.values$beta.SIM<
beta.ceram.n$sampled.values$beta.SIM))/100

p.value.beta.SIM
# The result is 0 and we used 100 samples, so p<0.01\
# 
# 
betapairout <- beta.pair(communityB, index.family="jac")
betapairout
```

```{r boral spider example, eval=FALSE}
library(mvabund) 
library(boral)
data(spider) 
y <- spider$abun #dim(y)
mcmc.control <- list(n.burnin = 1000, n.iteration = 4000, n.thin = 3, seed = 123)
# mcmc.control <- list(n.burnin = 10000, n.iteration = 40000, n.thin = 30, seed = 123)

## PART 1: Purely latent variable models assuming Poisson counts ## 
fit.lvmp <- boral(y = y, family = "poisson", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
summary(fit.lvmp)
fit.lvmp$hpdintervals
par(mfrow = c(2,2))
plot(fit.lvmp, ask = F, mfrow = c(2,2))
par(mfrow = c(1,1))
fit.lvmnb <- boral(y = y, family = "negative.binomial", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
summary(fit.lvmnb)
par(mfrow = c(2,2))
plot(fit.lvmnb, ask = F, mfrow = c(2,2))
par(mfrow = c(1,1))
lvsplot(fit.lvmnb, alpha = 0.55, main = "Unconstrained biplot")


fit.nbnoX <- boral(y = y, family = "negative.binomial", num.lv = 2, save.model = TRUE, mcmc.control = mcmc.control)
rescors.null <- get.residual.cor(fit.nbnoX)

X <- scale(spider$x) 
fit.Xnb <- boral(y = y, X = X, family = "negative.binomial", num.lv = 2, save.model = TRUE, mcmc.control = mcmc.control)
summary(fit.Xnb)
par(mfrow = c(2,2))
plot(fit.Xnb, ask = F, mfrow = c(2,2))
par(mfrow = c(1,1))

envcors <- get.enviro.cor(fit.Xnb) 
rescors <- get.residual.cor(fit.Xnb)

library(corrplot) 
corrplot(envcors$sig.cor, type = "lower", diag = F, title = "Correlations due to covariates", mar = c(3,0.5,2,1), tl.srt = 45)
corrplot(rescors$sig.cor, type = "lower", diag = F, title = "Residual correlations", mar = c(3,0.5,2,1), tl.srt = 45)
lvsplot(fit.Xnb, main = "Residual biplot", alpha = 0.55)
rescors.null$trace
rescors$trace
(rescors.null$trace-rescors$trace)/rescors.null$trace

fit.Xnb.ssvsgp <- boral(y = y, X = X, num.lv = 2, family = "negative.binomial", save.model = T, ssvs.index = 1:ncol(X))
summary(fit.Xnb.ssvsgp)

fit.Xnb.ssvsind <- boral(y = y, X = X, num.lv = 2, family = "negative.binomial", save.model = T, ssvs.index = 0)
summary(fit.Xnb.ssvsind)
summary(fit.Xnb.ssvsind$ssvs.indcoefs.mean)


n <- nrow(y); p <- ncol(y); 

## NOTE: The two examples below and taken directly from the boral help file

# example.mcmc.control <- list(n.burnin = 10, n.iteration = 100, n.thin = 1)

## Not run: 
## Example 3a - Extend example 2 to demonstrate grouped covariate selection
## on the last three covariates. 
set.prior <- list(type = c("normal","normal","normal","uniform"), hypparams = c(10, 10, 10, 30), ssvs.index = c(-1,-1,-1,1,2,3))

spider.fit.nb2 <- boral(y, X = X, family = "negative.binomial", 
	num.lv = 0, calc.ics = FALSE, mcmc.control = mcmc.control,
	prior.control = set.prior)
     
summary(spider.fit.nb2) 


## Example 3b - Extend example 2 to demonstrate individual covariate selection
## on the last three covariates. 
set.prior <- list(type = c("normal","normal","normal","uniform"), 
	hypparams = c(20, 20, 2, 50), ssvs.index = c(-1,-1,-1,0,0,0))
spider.fit.nb3 <- boral(y, X = X, family = "negative.binomial", 
	num.lv = 0, calc.ics = FALSE, mcmc.control = example.mcmc.control,
	prior.control = set.prior)
summary(spider.fit.nb3) 


data(antTraits) 
y <- antTraits$abun 
sel.spp <- colSums(y>0)>4 # ant has more than four traits with measurements
y <- y[,sel.spp] 
X <- antTraits$env ## Scale covariates to ease interpretability

traits <- model.matrix(~., data = antTraits$traits[sel.spp,])

```

```{r boral spider example 2, eval=FALSE}
library(boral)

## Not run: 
## NOTE: The values below MUST NOT be used in a real application;
## they are only used here to make the examples run quick!!!
example.mcmc.control <- list(n.burnin = 10, n.iteration = 100, 
     n.thin = 1)

library(mvabund) ## Load a dataset from the mvabund package
data(spider)
y <- spider$abun
n <- nrow(y); p <- ncol(y); 

X <- scale(spider$x)
spider.fit.nb <- boral(y, X = X, family = "negative.binomial", 
	num.lv = 2, mcmc.control = example.mcmc.control)


## Do separate line plots for all the coefficients of X
par(mfrow=c(2,3), mar = c(5,6,1,1))
sapply(colnames(spider.fit.nb$X), coefsplot, 
	spider.fit.nb)

## End(Not run)
```

```{r PD calc, eval=FALSE} 

########### phylocurve ##############

otu_table <- communityB
tree <- read.tree("./data/reIDotu443_outgroupOnychophora_tree.newick")

pd <- phylodiv(otu_table, tree)
pd <- phylocurve(otu_table, tree, stepm = 10, subsampling = "species", replace = FALSE)


####### beta diversity ######
#### PCA 
#install.packages("SparseM") ## need by library 'car'
#library(foreign)
#library(vegan)
#library(car)
#commNosrB <- commNosr
#commNosrB[commNosrB<3] <- 0 # according before results and field work experience, #JC forest seems get more alpha diversity. so drop those single read and double #reads cell
#commNosrB[commNosrB>1] <- 1
#
#hab <- habitat[,2:4]
#comm.pca <- rda(commNosrB)
#comm.pca <- rda(commNosrB~Habitat,habitat)
#comm.pca <- rda(commNosrB~Habitat*Altitude*Weather,habitat)
#summary(comm.pca)
#plot(comm.pca)


```



webpages to learn from 

http://evomics.org/wp-content/uploads/2016/01/phyloseq-Lab-01-Answers.html
http://rdp.cme.msu.edu/tutorials/RDPtutorial_CONTENTS.html
http://rdp.cme.msu.edu/tutorials/stats/using_rdp_output_with_phyloseq.html#supervised
http://rdp.cme.msu.edu/tutorials/stats/RDPtutorial_statistics.html
https://github.com/hallamlab/mp_tutorial/wiki/Taxonomic-Analysis
https://github.com/eheinzen/arsenal

https://grunwaldlab.github.io/metacoder_documentation


