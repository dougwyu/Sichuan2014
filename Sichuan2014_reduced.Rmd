---
title: "Re2014Sichuan-MBC"
output: html_document
---

I have set up github repo on github.com/dougwyu/Sichuan2014
Original filename:  Re2014_SiCMBC_Xiaoy0726.Rmd
Make sure that Source option is set to `Chunk output in Console` and do not select `Show Previews inline`

```{r setup, packages}
library(tidyverse) # includes all data-formatting packages as one big package (dplyr, tidyr, ggplot2, readr, readxl, tibble, and others)
library(vegan)
library(beanplot)
library(car)
library(iNEXT)
library(iNextPD)
library(ade4)
library(boral)
library(mvabund)
library(RColorBrewer)
library(betapart)

library(PDcalc)
library(ape)
library(phylocurve)
sessionInfo()
```


```{r load and format data}
# help(read_tsv)
# this inputfile contains taxononomic assignments in the lower rows
# command from readr package, and you tell the command how to format the columns

inputfile <- "./data/Sichuan2014_MBC_OTU443.txt" # post phyloseq filtering and filtering for trees

gfgMB <- read_tsv(
  inputfile, col_names = TRUE, na = "NA",
  col_types = cols(
    Site = col_character(),
    Habitat = col_factor(c("BB", "CL", "EC", "JC", "MF", "NF")),
    Type = col_factor(c("1", "2", "3", "4", "5", "6")),
    Altitude = col_integer(),
    Weather = col_integer()
    )
)

gfgMB <- tbl_df(gfgMB)
```

```{r environment dataset}
# make environment dataset
habitat <- gfgMB %>% dplyr::select(Site:Weather)
habitat <- habitat %>% dplyr::filter(!is.na(Habitat)) # remove taxonomy rows
```

```{r community build}
community <- gfgMB %>% dplyr::select(starts_with("Cluster_"))
# otuvector <- colnames(community)
community_t <- t(community)
community_t <- as.data.frame(community_t)
community_t <- rownames_to_column(community_t)
colnames(community_t) <- c("otu", gfgMB$Site) # add column names

communityAll_t <- community_t %>% filter(phylum=="Arthropoda")
communityAll_t <- community_t %>% select(-c(kingdom:species))
communityAll <- t(communityAll_t)
colvector <- communityAll[1,] # make a vector of the first row, which has the otu names
communityAll <- as.data.frame(communityAll)
colnames(communityAll) <-  colvector # add the otu names to the column names
communityAll <- communityAll[-1,]
# convert the columns to numeric from factor
# http://stackoverflow.com/questions/2288485/how-to-convert-a-data-frame-column-to-numeric-type
communityAll <- sapply(communityAll, function(x) as.numeric(as.character(x))) # sapply applies a function to each column, and the function is:  function(x) as.numeric(as.character(x)).  Cannot convert factors to numeric directly. first convert to character, then to numeric
communityAll <- as.data.frame(communityAll) # then convert to df
```

We used this code chunk to filter out small OTUs, leaving behind 443 OTUs. This is the dataset that we are importing as Sichuan2014_MBC_OTU443.txt.
```{r phyloseq filtering, eval=FALSE, include=FALSE}
# no longer need to run this code chunk because we have already used phyloseq to filter out small OTUs
# gsub("[[:punct:][:space:]]", "-", Sys.time()) #time will be shown
# source("https://bioconductor.org/biocLite.R") # to install phyloseq package
# biocLite("phyloseq")
library("phyloseq"); packageVersion("phyloseq")
library("data.table"); packageVersion("data.table")
library("ggplot2"); packageVersion("ggplot2")

TotalCounts <- c(colSums(communityAll))

tdt = data.table(colnames(communityAll),TotalCounts = colSums(communityAll),OTU = colnames(communityAll))

ggplot(tdt, aes(TotalCounts)) +  # histogram
  geom_histogram() + 
  ggtitle("Histogram of Total Counts")

taxcumsum = tdt[, .N, by = TotalCounts]
setkey(taxcumsum, TotalCounts)
taxcumsum[, CumSum := cumsum(N)]
# Define the plot
pCumSum = ggplot(taxcumsum, aes(TotalCounts, CumSum)) + 
  geom_point() +
  xlab("Filtering Threshold, Minimum Total Counts") +
  ylab("OTUs Filtered") +
  ggtitle("OTUs that would be filtered vs. the minimum count threshold")
pCumSum
pCumSum + xlim(0, 100)
pCumSum + xlim(0, 200)
pCumSum + xlim(0, 300)
pCumSum + xlim(0, 400)
pCumSum + xlim(0, 600)
pCumSum + xlim(0, 800)
pCumSum + xlim(0, 2000)
pCumSum + xlim(0, 20000)

## phyloseq-class experiment-level object
## otu_table()   OTU Table:         [ 3426 taxa and 34 samples ]
## sample_data() Sample Data:       [ 34 samples by 11 sample variables ]
## tax_table()   Taxonomy Table:    [ 3426 taxa by 7 taxonomic ranks ]
## phy_tree()    Phylogenetic Tree: [ 3426 tips and 3424 internal nodes ]

## from above result, we decide to use 2 thresholds to filter those small otus: 120 (>=120) and 40 (>=40)
## 40 gives us a table with 443 OTUs. This is the table that we are already reading. 
commMBC.120 <- communityAll[ ,colSums(communityAll)>=120] ## 336 otus remain
commMBC.120 <- commMBC.120[ rowSums(commMBC.120)>0,]
rowSums(commMBC.120)
commMBC.120 <- commMBC.120[-38,] #number 38 site has very few otu and reads number

commMBC.40 <- communityAll[ ,colSums(communityAll)>=40] ## 448 otus remain
commMBC.40 <- commMBC.40[ rowSums(commMBC.40)>0,]
rowSums(commMBC.40)
commMBC.40 <- commMBC.40[-38,]
colnames(commMBC.40)

```


```{r filter out low-read sites, }
rowSums(communityAll) # Three sites with very few reads ("JC04", "CL02", "BB02")

community <- communityAll
habitat$rowsums <- rowSums(community)
# these three sites have very few reads, so i'm removing them:  2, 110, and 380 reads
community <- community %>% filter(!(habitat$Site %in% c("JC04", "CL02", "BB02")))
habitatN <- habitat %>% filter(!(habitat$Site %in% c("JC04", "CL02", "BB02")))
rowSums(community)
```

```{r save datasets for GDM, eval=FALSE, include=FALSE}
write.table(community, "GDM_community.txt", sep = "\t")
write.table(habitatN, "GDM_environment.txt", sep = "\t")
```

```{r NMDS}
### do NMDS analysis to see basic patterns ####
community.jmds <- metaMDS(community, distance = "jaccard", trymax = 40, binary=TRUE)
community.jmds <- metaMDS(community, distance = "jaccard", binary = TRUE, previous.best = community.jmds)
 
stressplot(community.jmds)
```

```{r ordihull plot, }
#### plot the communities
levels(habitatN$Habitat)
(sprichness <- specnumber(community, MARGIN = 1)) # number of species per site

with(habitat, ordisurf(community.jmds, sprichness, main="", cex=0.5))
# with(habitat, ordisurf(community.jmds, Altitude, main="", cex=0.5))

with(habitatN, ordihull(community.jmds, Habitat, cex=.5, draw="polygon", col=c("blue"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("BB"))))

with(habitatN, ordihull(community.jmds, Habitat, cex=.5, draw="polygon", col=c("green"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("CL"))))

with(habitatN, ordihull(community.jmds, Habitat, cex=.5, draw="polygon", col=c("red"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("EC"))))

with(habitatN, ordihull(community.jmds, Habitat, cex=.5, draw="polygon", col=c("blue"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("JC"))))

with(habitatN, ordihull(community.jmds, Habitat, cex=.5, draw="polygon", col=c("lightgreen"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("MF"))))

with(habitatN, ordihull(community.jmds, Habitat, cex=.5, draw="polygon", col=c("darkgreen"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("NF"))))

```

Ordiellipse plots cover the 95% CIs for the species points, not the site points
```{r ordiellipse plot, eval=FALSE, include=FALSE}
#### plot the communities
levels(habitatN$Habitat)
(sprichness <- specnumber(community, MARGIN = 1)) # number of species per site
with(habitat, ordisurf(community.jmds, sprichness, main="", cex=0.5))
# with(habitat, ordisurf(community.jmds, Altitude, main="", cex=0.5))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("blue"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("BB"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("green"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("CL"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("red"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("EC"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("blue"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("JC"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("darkgreen"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("MF"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("darkgreen"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("NF"))))

```

If we want to identify individual points, we can use these commands. but not necessary now.
```{r ordiplots, eval=FALSE, include=FALSE}
# These commands are ways to identify points
orditorp(community.jmds, labels = habitatN$Site, dis="sites", pcol = "gray")
ordipointlabel(community.jmds, dis="sites")

#p1 <- plot(community.jmds, dis="sites")
#identify(p1, "sites") # interactive method to identify sites by row number. Click on the points that you want to identify. When you have clicked on all the points, click on the Finish button at top right of Plot window. 
```

```{r specpool, }
######### otu table with original reads number ######
(pool1 <- specpool(community, habitatN$Habitat))
```

   Species     chao  chao.se    jack1 jack1.se    jack2     boot  boot.se  n
BB     125 219.7378 30.74967 189.8889 25.55845 229.6528 153.2380 12.00890  9
CL     210 333.4333 35.52432 295.8667 26.84043 349.8476 247.2540 12.74553 15
EC      84 140.8969 21.74079 128.6250 20.80377 154.0179 103.6627 11.12558  8
JC     105 232.2995 44.94411 167.7273 23.60137 211.6636 131.2092 11.21026 11
MF     141 285.6838 43.12727 222.7778 32.32856 276.6389 175.8731 14.56185  9
NF     229 441.6250 51.79186 355.0000 43.14008 439.8095 282.3105 21.72050 15

```{r}
beanplot(specnumber(community)~habitatN$Habitat, col = c("grey", "white"))
```


```{r iNEXT}
# # example for incidence based data
# data(ant)
# str(ant)
# t <- seq(1, 700, by=10)
# out.inc <- iNEXT(ant, q=0, datatype="incidence_freq", size=t)
# ggiNEXT(out.inc, type = 1)
# out.inc$DataInfo
# vignette ("Introduction", package="iNEXT")
# http://chao.stat.nthu.edu.tw/wordpress/wp-content/uploads/software/iNEXT_UserGuide.pdf

communityB <- community
communityB[communityB>1] <- 1 # binary
rownames(communityB) # 67 rows
BB <- communityB %>% filter(habitatN$Habitat %in% c("BB"))
CL <- communityB %>% filter(habitatN$Habitat %in% c("CL"))
EC <- communityB %>% filter(habitatN$Habitat %in% c("EC"))
JC <- communityB %>% filter(habitatN$Habitat %in% c("JC"))
MF <- communityB %>% filter(habitatN$Habitat %in% c("MF"))
NF <- communityB %>% filter(habitatN$Habitat %in% c("NF"))

# rname <- rownames(BB_t)
cname <- c("BB","CL","EC","JC","MF","NF")
#    Species     chao  chao.se    jack1 jack1.se    jack2     boot  boot.se  n
# BB     125 219.7378 30.74967 189.8889 25.55845 229.6528 153.2380 12.00890  9
# CL     210 333.4333 35.52432 295.8667 26.84043 349.8476 247.2540 12.74553 15
# EC      84 140.8969 21.74079 128.6250 20.80377 154.0179 103.6627 11.12558  8
# JC     105 232.2995 44.94411 167.7273 23.60137 211.6636 131.2092 11.21026 11
# MF     141 285.6838 43.12727 222.7778 32.32856 276.6389 175.8731 14.56185  9
# NF     229 441.6250 51.79186 355.0000 43.14008 439.8095 282.3105 21.72050 15

comm4inext <- matrix(c(colSums(BB), colSums(CL), colSums(EC), colSums(JC), colSums(MF), colSums(NF)), ncol = 6)
# rownames(comm4inext) <- rname
colnames(comm4inext) <- cname
comm4inext <- rbind(c(nrow(BB), nrow(CL), nrow(EC), nrow(JC), nrow(MF), nrow(NF)), comm4inext)
comm4inext
confnum=0.95 # set confidence here
outcomm0 <- iNEXT(comm4inext, q=0, conf=confnum, datatype="incidence_freq")
# Hill numbers:  0 = sp richness, 1 = Shannon, 2 = inverse Simpson
outcomm0$DataInfo
ChaoRichness(comm4inext, datatype="incidence_freq") # same as specpool results, so i trust that we have done this correctly
ChaoShannon(comm4inext, datatype="incidence_freq")

outcomm1 <- iNEXT(comm4inext, q=1, conf=confnum, datatype="incidence_freq")
ggiNEXT(outcomm1, type=1)
outcomm2 <- iNEXT(comm4inext, q=2, conf=confnum, datatype="incidence_freq")
ggiNEXT(outcomm2, type=1)

ggiNEXT(outcomm0, type=1) # sample-size-based rarefaction/extrapolation curve
ggiNEXT(outcomm1, type=1) # sample-size-based rarefaction/extrapolation curve
ggiNEXT(outcomm0, type=2) # sample completeness curve
ggiNEXT(outcomm0, type=3) # coverage-based rarefaction/extrapolation curve

outcomm0$DataInfo
outcomm0$iNextEst
outcomm0$AsyEst
```

```{r iNextPD test, eval=FALSE, include=FALSE}
data(bird)
str(bird)
bird.lab <- rownames(bird$abun)
bird.phy <- ade4::newick2phylog(bird$tre)
# plot(bird.phy)
table.phylog(bird$abun, bird.phy, csize=4, f.phylog=0.7)
outcommbird <- iNextPD(x=bird$abun, labels=bird.lab, phy=bird.phy, q=0, datatype="abundance")
ggiNEXT(outcommbird, type=1, se=TRUE, facet.var="none", color.var="site", grey=FALSE)
ggiNEXT(outcommbird, type=2, se=TRUE, facet.var="none", color.var="site", grey=FALSE)
ggiNEXT(outcommbird, type=3, se=TRUE, facet.var="none", color.var="site", grey=FALSE)

out <- iNextPD(bird$abun, bird.lab, bird.phy, q=c(0, 1, 2), datatype="abundance", endpoint=400)

# Sample‐size‐based R/E curves, separating by "site""
ggiNEXT(out, type=1, facet.var="site")
# Sample‐size‐based R/E curves, separating by "order"
ggiNEXT(out, type=1, facet.var="order")
# display black‐white theme
ggiNEXT(out, type=1, facet.var="order", grey=TRUE)


# incidence data

bird.lab <- rownames(bird$abun)  # OTU names
bird.phy <- ade4::newick2phylog(bird$tre) # convert newick tree to phylog object
out.inc <- iNextPD(bird$inci, bird.lab, bird.phy, 
                   q=0, datatype="incidence_raw", 
                   endpoint = 25, se=TRUE)

# Sample‐size‐based R/E curves
ggiNEXT(out.inc, type=1, color.var="site") + 
  theme_bw(base_size = 18) + 
  theme(legend.position="none")

ggiNEXT(out.inc, type=2, color.var="site") +
  xlim(c(5,25)) + ylim(c(0.7,1)) +
  theme_bw(base_size = 18) + 
  theme(legend.position="none")

```

Testing different errors
```{r boral, cache=TRUE, eval=FALSE, include=FALSe}
mcmc.control <- list(n.burnin = 300, n.iteration = 3000, n.thin = 30)

colnames(community) <- c(1:443)
colnames(communityB) <- c(1:443)

#### Negative binomial 
comm.fit.nb3 <- boral(community, family = "negative.binomial", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control) 
latvarscomm.fit.nb3 <- comm.fit.nb3[["lv.median"]]
summary(comm.fit.nb3)
par(mfrow = c(2,2))
plot(comm.fit.nb3) ## Plots used in residual analysis, 
par(mfrow = c(1,1))

# par(mfrow = c(1,2))
lvsplot(comm.fit.nb3, biplot=FALSE, col=as.numeric(habitatN$Habitat))
# plot(lv2 ~ lv1, data = latvarscomm.fit.nb3, col=as.numeric(habitatN$Habitat))
# par(mfrow = c(1,1))

commB.fit.nb3 <- boral(communityB, family = "negative.binomial", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
summary(commB.fit.nb3)
par(mfrow = c(2,2))
plot(commB.fit.nb3) ## Plots used in residual analysis, 
par(mfrow = c(1,1))
lvsplot(commB.fit.nb3, biplot=FALSE)

#### Poisson
commB.fit.pb3 <- boral(communityB, family = "poisson", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
summary(commB.fit.pb3)
par(mfrow = c(2,2))
plot(commB.fit.pb3) ## Plots used in residual analysis, 
par(mfrow = c(1,1))
lvsplot(commB.fit.pb3, biplot=FALSE)

#### Binomial
commB.fit.b3 <- boral(communityB, family = "binomial", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
summary(commB.fit.b3)
par(mfrow = c(2,2))
plot(commB.fit.b3) ## Plots used in residual analysis, 
par(mfrow = c(1,1))
lvsplot(commB.fit.b3, biplot=FALSE)

# #### Ordinal  # does not run, even overnight
# communityO <- community+1
# comm.fit.o3 <- boral(communityO, family = "ordinal", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
# summary(comm.fit.o3)
# par(mfrow = c(2,2))
# plot(comm.fit.o3) ## Plots used in residual analysis, 
# par(mfrow = c(1,1))
# lvsplot(comm.fit.o3, biplot=FALSE)
```

Poisson and Binomial to produce the best residuals. I re-ran with more iterations, and Binomial had the best (slightly) residuals.  So i have settled on Binomial, which is expected.
```{r boral high iterations, }

colnames(community) <- c(1:443)
colnames(communityB) <- c(1:443)

# mcmc.control4 <- list(n.burnin = 10000, n.iteration = 40000, n.thin = 30, seed = 123)
mcmc.control4 <- list(n.burnin = 10000, n.iteration = 40000, n.thin = 30)

# #### Poisson
# commB.fit.pb3.4 <- boral(communityB, family = "poisson", num.lv = 3, row.eff = "fixed", mcmc.control = mcmc.control4, save.model = TRUE)  # high iterations
# summary(commB.fit.pb3.4)
# par(mfrow = c(2,2))
# plot(commB.fit.pb3.4) ## Plots used in residual analysis, 
# par(mfrow = c(1,1))
# mypalette <- brewer.pal(6, "Dark2")
# par(mfrow = c(1,2))
# lvsplot(commB.fit.pb3.4, col = as.numeric(habitatN$Habitat), pch = 16) # ind.spp = 5:  show top 5 most important indicator species
# plot(commB.fit.pb3.4[["lv.median"]][,1] ~ commB.fit.pb3.4[["lv.median"]][,2], col = as.numeric(habitatN$Habitat), pch = 16)  # to get just points, which we can then format as we want
# par(mfrow = c(1,1))
# # saveRDS(commB.fit.pb3.4, "commB.fit.pb3.4.RDS")

#### Binomial
commB.fit.b3.4 <- boral(communityB, family = "binomial", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control4, save.model = TRUE)
summary(commB.fit.b3.4)
par(mfrow = c(2,2))
plot(commB.fit.b3.4) ## Plots used in residual analysis, 
par(mfrow = c(1,1))
par(mfrow = c(1,2))
lvsplot(commB.fit.b3.4, biplot=FALSE, col = as.numeric(habitatN$Habitat))
plot(commB.fit.b3.4[["lv.median"]][,1] ~ commB.fit.b3.4[["lv.median"]][,2], col = as.numeric(habitatN$Habitat), pch = 16)  # to get just points, which we can then format as we want
par(mfrow = c(1,1))
saveRDS(commB.fit.b3.4, "commB.fit.b3.4.RDS")

# commB.fit.b3.4 <- readRDS("commB.fit.b3.4.RDS")
```

```{r betapart}
# Read the data for Northern and Southern European cerambycids
data(ceram.s)
data(ceram.n)

ceram.dist<-beta.pair(ceram.s, index.family="jac")
ceram.beta<-beta.multi(ceram.s, index.family="sor")

# Resample 100 times the multiple-site dissimilarities
# for 10 countries.
beta.ceram.s<-beta.sample(ceram.s, index.family="sor", sites=10, samples=100)
beta.ceram.n<-beta.sample(ceram.n, index.family="sor", sites=10, samples=100)

# Plot the distributions of beta.SIM in Southern Europe (red) 
# and Northern Europe (blue)
plot(density(beta.ceram.s$sampled.values$beta.SIM), col="red", xlim=c(0,1))
lines(density(beta.ceram.n$sampled.values$beta.SIM), col="blue")

# Compute the p-value of difference in beta.SIM between South and North 
# (i.e. the probability of finding in the North a higher value than 
# in the South)
p.value.beta.SIM<-length(which(beta.ceram.s$sampled.values$beta.SIM<
beta.ceram.n$sampled.values$beta.SIM))/100

p.value.beta.SIM
# The result is 0 and we used 100 samples, so p<0.01\
# 
# 
betapairout <- beta.pair(communityB, index.family="jac")
betapairout
```




```{r boral example, eval=FALSE}
library(mvabund)
library(boral)
data(spider) 
y <- spider$abun #dim(y)
mcmc.control <- list(n.burnin = 10000, n.iteration = 40000, n.thin = 30, seed = 123)

## PART 1: Purely latent variable models assuming Poisson counts ## 
fit.lvmp <- boral(y = y, family = "poisson", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
summary(fit.lvmp)
fit.lvmp$hpdintervals
par(mfrow = c(2,2))
plot(fit.lvmp, ask = F, mfrow = c(2,2))
par(mfrow = c(1,1))
fit.lvmnb <- boral(y = y, family = "negative.binomial", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
summary(fit.lvmnb)
par(mfrow = c(2,2))
plot(fit.lvmnb, ask = F, mfrow = c(2,2))
par(mfrow = c(1,1))
lvsplot(fit.lvmnb, alpha = 0.55, main = "Unconstrained biplot")


fit.nbnoX <- boral(y = y, family = "negative.binomial", num.lv = 2, save.model = TRUE, mcmc.control = mcmc.control)
rescors.null <- get.residual.cor(fit.nbnoX)

X <- scale(spider$x) 
fit.Xnb <- boral(y = y, X = X, family = "negative.binomial", num.lv = 2, save.model = TRUE, mcmc.control = mcmc.control)
summary(fit.Xnb)
par(mfrow = c(2,2))
plot(fit.Xnb, ask = F, mfrow = c(2,2))
par(mfrow = c(1,1))

envcors <- get.enviro.cor(fit.Xnb) 
rescors <- get.residual.cor(fit.Xnb)

library(corrplot) 
corrplot(envcors$sig.cor, type = "lower", diag = F, title = "Correlations due to covariates", mar = c(3,0.5,2,1), tl.srt = 45)
corrplot(rescors$sig.cor, type = "lower", diag = F, title = "Residual correlati ons", mar = c(3,0.5,2,1), tl.srt = 45)
lvsplot(fit.Xnb, main = "Residual biplot", alpha = 0.55)
rescors.null$trace
rescors$trace
(rescors.null$trace-rescors$trace)/rescors.null$trace
fit.Xnb.ssvsgp <- boral(y = y, X = X, num.lv = 2, family = "negative.binomial", save.model = T, ssvs.index = 1:ncol(X))
summary(fit.Xnb.ssvsgp)

fit.Xnb.ssvsind <- boral(y = y, X = X, num.lv = 2, family = "negative.binomial", save.model = T, ssvs.index = 0)
summary(fit.Xnb.ssvsind)
summary(fit.Xnb.ssvsind$ssvs.indcoefs.mean)

data(antTraits) 
y <- antTraits$abun 
sel.spp <- colSums(y>0)>4 # ant has more than four traits with measurements
y <- y[,sel.spp] 
X <- antTraits$env ## Scale covariates to ease interpretability

traits <- model.matrix(~., data = antTraits$traits[sel.spp,])

```


```{r tabasco}
vegemite(communityB)
tabasco(communityB)

x0 <- communityB %>% filter(habitatN$Habitat %in% c("BB")) %>% colSums()
x1 <- communityB %>% filter(habitatN$Habitat %in% c("CL")) %>% colSums()
x2 <- communityB %>% filter(habitatN$Habitat %in% c("EC")) %>% colSums()
x3 <- communityB %>% filter(habitatN$Habitat %in% c("JC")) %>% colSums()
x4 <- communityB %>% filter(habitatN$Habitat %in% c("MF")) %>% colSums()
x5 <- communityB %>% filter(habitatN$Habitat %in% c("NF")) %>% colSums()

habSum <- matrix(c(x0,x1,x2,x3,x4,x5), ncol = 443)

colnames(habSum)
rownames(habSum)
row <- c("BB","CL","EC","JC","MF","NF")
col <- c(1:443)
dimnames(habSum) <- list(row,col)

vegemite(habSum, scale = "Hill")
tabasco(habSum)

knitr::opts_chunk$set(echo = TRUE)
```




after this, do mvabund and betapart

```{r}
library(boral)

## Not run: 
## NOTE: The values below MUST NOT be used in a real application;
## they are only used here to make the examples run quick!!!
example.mcmc.control <- list(n.burnin = 10, n.iteration = 100, 
     n.thin = 1)

library(mvabund) ## Load a dataset from the mvabund package
data(spider)
y <- spider$abun
n <- nrow(y); p <- ncol(y); 

X <- scale(spider$x)
spider.fit.nb <- boral(y, X = X, family = "negative.binomial", 
	num.lv = 2, mcmc.control = example.mcmc.control)


## Do separate line plots for all the coefficients of X
par(mfrow=c(2,3), mar = c(5,6,1,1))
sapply(colnames(spider.fit.nb$X), coefsplot, 
	spider.fit.nb)

## End(Not run)
```


```{r PD calc} 

########### phylocurve ##############

otu_table <- communityB
tree <- read.tree("./data/reIDotu443_outgroupOnychophora_tree.newick")

pd <- phylodiv(otu_table, tree)
pd <- phylocurve(otu_table, tree, stepm = 10, subsampling = "species", replace = FALSE)


####### beta diversity ######
#### PCA 
#install.packages("SparseM") ## need by library 'car'
#library(foreign)
#library(vegan)
#library(car)
#commNosrB <- commNosr
#commNosrB[commNosrB<3] <- 0 # according before results and field work experience, #JC forest seems get more alpha diversity. so drop those single read and double #reads cell
#commNosrB[commNosrB>1] <- 1
#
#hab <- habitat[,2:4]
#comm.pca <- rda(commNosrB)
#comm.pca <- rda(commNosrB~Habitat,habitat)
#comm.pca <- rda(commNosrB~Habitat*Altitude*Weather,habitat)
#summary(comm.pca)
#plot(comm.pca)


```



webpages to learn from 

http://evomics.org/wp-content/uploads/2016/01/phyloseq-Lab-01-Answers.html
http://rdp.cme.msu.edu/tutorials/RDPtutorial_CONTENTS.html
http://rdp.cme.msu.edu/tutorials/stats/using_rdp_output_with_phyloseq.html#supervised
http://rdp.cme.msu.edu/tutorials/stats/RDPtutorial_statistics.html
https://github.com/hallamlab/mp_tutorial/wiki/Taxonomic-Analysis
https://github.com/eheinzen/arsenal

https://grunwaldlab.github.io/metacoder_documentation


