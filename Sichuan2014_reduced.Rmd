---
title: "Re2014Sichuan-MBC"
output: html_document
---

I have set up github repo on github.com/dougwyu/Sichuan2014
Original filename:  Re2014_SiCMBC_Xiaoy0726.Rmd
Make sure that Source option is set to `Chunk output in Console` and do not select `Show Previews inline`


## Tentative conclusions

1) Mosaic forest compositions are largely driven by Bamboo communities, plus a bit more from the other plantations.   Do we have a list of what each MF is made of?

## To do:

1)  mvabund or boral to test for sig compositional differences between forest types (esp. btw MF and BB, JC, EU)
2)  stacked barchart of multi-site beta diversity metrics
3)  do this analysis with birds? 
4)  also report Kat's results about mixed vs. mosaic?


```{r setup, packages}
library(tidyverse) # includes all data-formatting packages as one big package (dplyr, tidyr, ggplot2, readr, readxl, tibble, and others)
library(vegan)
library(beanplot)
library(car)
library(iNEXT)
library(iNextPD)
library(ade4)
library(boral)
library(mvabund)
library(RColorBrewer)
library(betapart)

library(PDcalc)
library(ape)
library(phylocurve)
sessionInfo()
```


```{r load and format data}
# help(read_tsv)
# this inputfile contains taxononomic assignments in the lower rows
# command from readr package, and you tell the command how to format the columns

# inputfile <- "./data/Sichuan2014_MBC_OTU443.txt" # post phyloseq filtering and filtering for trees
inputfile <- "./data/2014MBC_otu746table_with_Env20.txt" # post phyloseq filtering and filtering for trees, using final bioinformatics pipeline with vsearch and RDP Classifier and phyloseq at min20reads

gfgMB <- read_tsv(
  inputfile, col_names = TRUE, na = "NA",
  col_types = cols(
    Site = col_character(),
    Habitat = col_factor(c("BB", "CL", "EC", "JC", "MF", "NF")),
    Type = col_factor(c("1", "2", "3", "4", "5", "6")),
    Altitude = col_integer(),
    Weather = col_integer()
    )
)

gfgMB <- tbl_df(gfgMB)
```

```{r environment dataset}
# make environment dataset
habitat <- gfgMB %>% dplyr::select(Site:Weather)
habitat <- habitat %>% dplyr::filter(!is.na(Habitat)) # remove taxonomy rows
```

```{r community build}
community <- gfgMB %>% dplyr::select(starts_with("Cluster"))
# otuvector <- colnames(community)
community_t <- t(community)
community_t <- as.data.frame(community_t)
community_t <- rownames_to_column(community_t)
colnames(community_t) <- c("otu", gfgMB$Site) # add column names

communityAll_t <- community_t %>% filter(phylum=="Arthropoda")
communityAll_t <- community_t %>% select(-c(kingdom:species))
communityAll <- t(communityAll_t)
colvector <- communityAll[1,] # make a vector of the first row, which has the otu names
communityAll <- as.data.frame(communityAll)
colnames(communityAll) <-  colvector # add the otu names to the column names
communityAll <- communityAll[-1,]
# convert the columns to numeric from factor
# http://stackoverflow.com/questions/2288485/how-to-convert-a-data-frame-column-to-numeric-type
communityAll <- sapply(communityAll, function(x) as.numeric(as.character(x))) # sapply applies a function to each column, and the function is:  function(x) as.numeric(as.character(x)).  Cannot convert factors to numeric directly. first convert to character, then to numeric
communityAll <- as.data.frame(communityAll) # then convert to df
```

We used this code chunk to filter out small OTUs, leaving behind 443 OTUs. This is the dataset that we are importing as Sichuan2014_MBC_OTU443.txt.
```{r phyloseq filtering, eval=FALSE, include=FALSE}
# no longer need to run this code chunk because we have already used phyloseq to filter out small OTUs
# gsub("[[:punct:][:space:]]", "-", Sys.time()) #time will be shown
# source("https://bioconductor.org/biocLite.R") # to install phyloseq package
# biocLite("phyloseq")
library("phyloseq"); packageVersion("phyloseq")
library("data.table"); packageVersion("data.table")
library("ggplot2"); packageVersion("ggplot2")

TotalCounts <- c(colSums(communityAll))

tdt = data.table(colnames(communityAll),TotalCounts = colSums(communityAll),OTU = colnames(communityAll))

ggplot(tdt, aes(TotalCounts)) +  # histogram
  geom_histogram() + 
  ggtitle("Histogram of Total Counts")

taxcumsum = tdt[, .N, by = TotalCounts]
setkey(taxcumsum, TotalCounts)
taxcumsum[, CumSum := cumsum(N)]
# Define the plot
pCumSum = ggplot(taxcumsum, aes(TotalCounts, CumSum)) + 
  geom_point() +
  xlab("Filtering Threshold, Minimum Total Counts") +
  ylab("OTUs Filtered") +
  ggtitle("OTUs that would be filtered vs. the minimum count threshold")
pCumSum
pCumSum + xlim(0, 100)
pCumSum + xlim(0, 200)
pCumSum + xlim(0, 300)
pCumSum + xlim(0, 400)
pCumSum + xlim(0, 600)
pCumSum + xlim(0, 800)
pCumSum + xlim(0, 2000)
pCumSum + xlim(0, 20000)

## phyloseq-class experiment-level object
## otu_table()   OTU Table:         [ 3426 taxa and 34 samples ]
## sample_data() Sample Data:       [ 34 samples by 11 sample variables ]
## tax_table()   Taxonomy Table:    [ 3426 taxa by 7 taxonomic ranks ]
## phy_tree()    Phylogenetic Tree: [ 3426 tips and 3424 internal nodes ]

## from above result, we decide to use 2 thresholds to filter those small otus: 120 (>=120) and 40 (>=40)
## 40 gives us a table with 443 OTUs. This is the table that we are already reading. 
commMBC.120 <- communityAll[ ,colSums(communityAll)>=120] ## 336 otus remain
commMBC.120 <- commMBC.120[ rowSums(commMBC.120)>0,]
rowSums(commMBC.120)
commMBC.120 <- commMBC.120[-38,] #number 38 site has very few otu and reads number

commMBC.40 <- communityAll[ ,colSums(communityAll)>=40] ## 448 otus remain
commMBC.40 <- commMBC.40[ rowSums(commMBC.40)>0,]
rowSums(commMBC.40)
commMBC.40 <- commMBC.40[-38,]
colnames(commMBC.40)

```

Filter out sites with (1) very low numbers of reads, (2) very low numbers of species
```{r filter out sites, }
community <- communityAll
habitat$rowsums <- rowSums(community)
habitat$sprichness <- specnumber(community, MARGIN = 1) # number of species per site

# View(habitat) 
# remove 3 sites that have only 2 and 38 reads
community <- community %>% filter(!(habitat$Site %in% c("JC04", "CL02")))
habitatN <- habitat %>% filter(!(habitat$Site %in% c("JC04", "CL02")))
rowSums(community)

# remove 10 sites that have <10 species
community <- community %>% filter(habitatN$sprichness >= 10)
habitatN <- habitatN %>% filter(habitatN$sprichness >= 10)

habitatN <- droplevels(habitatN)

# should I rarefy the dataset?
# with(habitatN, plot(sprichness ~ rowsums))
# with(habitatN, abline(lm(sprichness~rowsums)))
# sprichness_mod <- with(habitatN, lm(sprichness ~ rowsums)); summary(sprichness_mod)
# sort(rowSums(community)) 
# There is no clear relationship between row sums and species richness, except that the max species richness is higher between 15,000 and 60,000 compared to < 15,000 reads.  But lots of high read number sites sites have few species.  So no call for rarefaction


# data(BCI)
# S <- specnumber(BCI) # observed number of species
# (raremax <- min(rowSums(BCI)))
# Srare <- rarefy(BCI, raremax)
# plot(S, Srare, xlab = "Observed No. of Species", ylab = "Rarefied No. of Species")
# abline(0, 1)
# rarecurve(BCI, step = 20, sample = raremax, col = "blue", cex = 0.6)
```

```{r save datasets for GDM, eval=FALSE, include=FALSE}
write.table(community, "GDM_community.txt", sep = "\t")
write.table(habitatN, "GDM_environment.txt", sep = "\t")
```

```{r NMDS}
### do NMDS analysis to see basic patterns ####
communityB <- community
communityB[communityB>1] <- 1 # binary
rownames(communityB) # 58 rows
community.jmds <- metaMDS(communityB, distance = "jaccard", trymax = 40, binary=TRUE)
community.jmds <- metaMDS(communityB, distance = "jaccard", binary = TRUE, previous.best = community.jmds)
stressplot(community.jmds)
```

```{r ordispider plot, }
#### plot the communities
levels(habitatN$Habitat)
(sprichness <- specnumber(community, MARGIN = 1)) # number of species per site
colvec <- brewer.pal(5, "Set1")

# with(habitatN, ordisurf(community.jmds, sprichness, main="NMDS - species richness contour", cex=0.5, col = "grey"))
with(habitatN, ordisurf(community.jmds, Altitude, main=" NMDS - Altitude contour", cex=0.5, col = "grey"))

with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("BB"))))

with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[1]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("CL"))))

with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("EC"))))

with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("JC"))))

with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("MF"))))

with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("NF"))))

```

```{r}
tabasco(community, use = community.jmds, labCol = habitat$Habitat, col = brewer.pal(3, "Oranges"))
```

Ordiellipse plots cover the 95% CIs for the species points, not the site points
```{r ordiellipse plot, eval=FALSE, include=FALSE}
#### plot the communities
levels(habitatN$Habitat) 
(sprichness <- specnumber(community, MARGIN = 1)) # number of species per site

with(habitatN, ordisurf(community.jmds, sprichness, main="", cex=0.5, col = "grey"))
# with(habitat, ordisurf(community.jmds, Altitude, main="", cex=0.5))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("BB"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[1]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("CL"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("EC"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("JC"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("darkblue"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("MF"))))

with(habitatN, ordiellipse(community.jmds, Habitat, cex=.5, draw="polygon", col=c("darkblue"), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
# with(habitatN, ordispider(community.jmds, Habitat, main="", show.groups=(c("NF"))))

```

If we want to identify individual points, we can use these commands. but not necessary now.
```{r ordiplots, eval=FALSE, include=FALSE}
# These commands are ways to identify points 
orditorp(community.jmds, labels = habitatN$Site, dis="sites", pcol = "gray")
ordipointlabel(community.jmds, dis="sites")

#p1 <- plot(community.jmds, dis="sites")
#identify(p1, "sites") # interactive method to identify sites by row number. Click on the points that you want to identify. When you have clicked on all the points, click on the Finish button at top right of Plot window. 
```

```{r specpool, }
######### otu table with original reads number ######
(pool1 <- specpool(communityB, habitatN$Habitat))
```

   Species     chao   chao.se    jack1 jack1.se    jack2     boot  boot.se  n
BB     149 370.8696  64.69408 243.5000 37.70196 309.7143 188.5740 15.81506  8
CL     291 573.3333  63.13579 445.0000 47.13102 551.7857 356.0191 21.63914 15
EC      91 141.6250  18.63480 136.0000 22.26732 159.2000 111.3077 11.11202  6
JC     136 413.3595  88.26131 227.5556 39.48058 296.0972 173.6671 17.55551  9
MF     195 589.9402 102.46346 330.1111 52.50279 430.6389 250.6104 21.91161  9
NF     278 684.0888  87.21601 456.1818 64.32999 584.8818 352.0013 28.02073 11

```{r}
beanplot(specnumber(communityB)~habitatN$Habitat, col = c("grey", "white"))
```

```{r iNEXT}
# # example for incidence based data
# data(ant)
# str(ant)
# t <- seq(1, 700, by=10)
# out.inc <- iNEXT(ant, q=0, datatype="incidence_freq", size=t)
# ggiNEXT(out.inc, type = 1)
# out.inc$DataInfo
# vignette ("Introduction", package="iNEXT")
# http://chao.stat.nthu.edu.tw/wordpress/wp-content/uploads/software/iNEXT_UserGuide.pdf


BB <- communityB %>% filter(habitatN$Habitat %in% c("BB"))
CL <- communityB %>% filter(habitatN$Habitat %in% c("CL"))
EC <- communityB %>% filter(habitatN$Habitat %in% c("EC"))
JC <- communityB %>% filter(habitatN$Habitat %in% c("JC"))
MF <- communityB %>% filter(habitatN$Habitat %in% c("MF"))
NF <- communityB %>% filter(habitatN$Habitat %in% c("NF"))

# rname <- rownames(BB_t)
cname <- c("BB","CL","EC","JC","MF","NF")
#    Species     chao  chao.se    jack1 jack1.se    jack2     boot  boot.se  n
# BB     125 219.7378 30.74967 189.8889 25.55845 229.6528 153.2380 12.00890  9
# CL     210 333.4333 35.52432 295.8667 26.84043 349.8476 247.2540 12.74553 15
# EC      79 125.0800 18.14375 117.4000 20.40392 137.2000  96.3264  9.65950  5
# JC     103 213.8395 39.07452 162.5556 23.27718 202.4167 128.2358 10.61719  9
# MF     141 285.6838 43.12727 222.7778 32.32856 276.6389 175.8731 14.56185  9
# NF     223 423.0117 49.47008 342.0909 42.99145 420.5545 273.7362 20.08776 11

comm4inext <- matrix(c(colSums(BB), colSums(CL), colSums(EC), colSums(JC), colSums(MF), colSums(NF)), ncol = 6)
# rownames(comm4inext) <- rname
colnames(comm4inext) <- cname
comm4inext <- rbind(c(nrow(BB), nrow(CL), nrow(EC), nrow(JC), nrow(MF), nrow(NF)), comm4inext)
comm4inext
confnum=0.95 # set confidence here
outcomm0 <- iNEXT(comm4inext, q=0, conf=confnum, datatype="incidence_freq")
# Hill numbers:  0 = sp richness, 1 = Shannon, 2 = inverse Simpson
outcomm0$DataInfo
ChaoRichness(comm4inext, datatype="incidence_freq") # same as specpool results, so i trust that we have done this correctly
ChaoShannon(comm4inext, datatype="incidence_freq")

outcomm1 <- iNEXT(comm4inext, q=1, conf=confnum, datatype="incidence_freq")
ggiNEXT(outcomm1, type=1)
outcomm2 <- iNEXT(comm4inext, q=2, conf=confnum, datatype="incidence_freq")
ggiNEXT(outcomm2, type=1)

ggiNEXT(outcomm0, type=1) # sample-size-based rarefaction/extrapolation curve
ggiNEXT(outcomm1, type=1) # sample-size-based rarefaction/extrapolation curve
ggiNEXT(outcomm0, type=2) # sample completeness curve
ggiNEXT(outcomm0, type=3) # coverage-based rarefaction/extrapolation curve

outcomm0$DataInfo
outcomm0$iNextEst
outcomm0$AsyEst
```

```{r iNextPD test, eval=FALSE, include=FALSE}
data(bird)
str(bird)
bird.lab <- rownames(bird$abun)
bird.phy <- ade4::newick2phylog(bird$tre)
# plot(bird.phy)
table.phylog(bird$abun, bird.phy, csize=4, f.phylog=0.7)
outcommbird <- iNextPD(x=bird$abun, labels=bird.lab, phy=bird.phy, q=0, datatype="abundance")
ggiNEXT(outcommbird, type=1, se=TRUE, facet.var="none", color.var="site", grey=FALSE)
ggiNEXT(outcommbird, type=2, se=TRUE, facet.var="none", color.var="site", grey=FALSE)
ggiNEXT(outcommbird, type=3, se=TRUE, facet.var="none", color.var="site", grey=FALSE)

out <- iNextPD(bird$abun, bird.lab, bird.phy, q=c(0, 1, 2), datatype="abundance", endpoint=400)

# Sample‐size‐based R/E curves, separating by "site""
ggiNEXT(out, type=1, facet.var="site")
# Sample‐size‐based R/E curves, separating by "order"
ggiNEXT(out, type=1, facet.var="order")
# display black‐white theme
ggiNEXT(out, type=1, facet.var="order", grey=TRUE)


# incidence data

bird.lab <- rownames(bird$abun)  # OTU names
bird.phy <- ade4::newick2phylog(bird$tre) # convert newick tree to phylog object
out.inc <- iNextPD(bird$inci, bird.lab, bird.phy, 
                   q=0, datatype="incidence_raw", 
                   endpoint = 25, se=TRUE)

# Sample‐size‐based R/E curves
ggiNEXT(out.inc, type=1, color.var="site") + 
  theme_bw(base_size = 18) + 
  theme(legend.position="none")

ggiNEXT(out.inc, type=2, color.var="site") +
  xlim(c(5,25)) + ylim(c(0.7,1)) +
  theme_bw(base_size = 18) + 
  theme(legend.position="none")

```

Testing different errors
```{r boral, cache=TRUE, eval=FALSE, include=FALSE}
mcmc.control <- list(n.burnin = 300, n.iteration = 3000, n.thin = 30)

# colnames(community) <- c(1:443)
# colnames(communityB) <- c(1:443)

#### Negative binomial 
comm.fit.nb3 <- boral(community, family = "negative.binomial", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control) 
latvarscomm.fit.nb3 <- comm.fit.nb3[["lv.median"]]
summary(comm.fit.nb3)
par(mfrow = c(2,2))
plot(comm.fit.nb3) ## Plots used in residual analysis, 
par(mfrow = c(1,1))

# par(mfrow = c(1,2))
lvsplot(comm.fit.nb3, biplot=FALSE, col=as.numeric(habitatN$Habitat))
# plot(lv2 ~ lv1, data = latvarscomm.fit.nb3, col=as.numeric(habitatN$Habitat))
# par(mfrow = c(1,1))

commB.fit.nb3 <- boral(communityB, family = "negative.binomial", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
summary(commB.fit.nb3)
par(mfrow = c(2,2))
plot(commB.fit.nb3) ## Plots used in residual analysis, 
par(mfrow = c(1,1))
lvsplot(commB.fit.nb3, biplot=FALSE)

#### Poisson
commB.fit.pb3 <- boral(communityB, family = "poisson", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
summary(commB.fit.pb3)
par(mfrow = c(2,2))
plot(commB.fit.pb3) ## Plots used in residual analysis, 
par(mfrow = c(1,1))
lvsplot(commB.fit.pb3, biplot=FALSE)

#### Binomial
commB.fit.b3 <- boral(communityB, family = "binomial", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
summary(commB.fit.b3)
par(mfrow = c(2,2))
plot(commB.fit.b3) ## Plots used in residual analysis, 
par(mfrow = c(1,1))
lvsplot(commB.fit.b3, biplot=FALSE, col = as.numeric(habitatN$Habitat))

# #### Ordinal  # does not run, even overnight
# communityO <- community+1
# comm.fit.o3 <- boral(communityO, family = "ordinal", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
# summary(comm.fit.o3)
# par(mfrow = c(2,2))
# plot(comm.fit.o3) ## Plots used in residual analysis, 
# par(mfrow = c(1,1))
# lvsplot(comm.fit.o3, biplot=FALSE)
```

Poisson and Binomial to produce the best residuals. I re-ran with more iterations, and Binomial had the best (slightly) residuals.  So i have settled on Binomial, which is expected.
```{r boral high iterations, eval=FALSE}

# colnames(community) <- c(1:443) 
# colnames(communityB) <- c(1:443)

# mcmc.control4 <- list(n.burnin = 10000, n.iteration = 40000, n.thin = 30, seed = 123)
mcmc.control4 <- list(n.burnin = 10000, n.iteration = 40000, n.thin = 30)

# #### Poisson
# commB.fit.pb3.4 <- boral(communityB, family = "poisson", num.lv = 3, row.eff = "fixed", mcmc.control = mcmc.control4, save.model = TRUE)  # high iterations 
# summary(commB.fit.pb3.4) 
# par(mfrow = c(2,2))
# plot(commB.fit.pb3.4) ## Plots used in residual analysis, 
# par(mfrow = c(1,1))
# mypalette <- brewer.pal(6, "Dark2")
# par(mfrow = c(1,2))
# lvsplot(commB.fit.pb3.4, col = as.numeric(habitatN$Habitat), pch = 16) # ind.spp = 5:  show top 5 most important indicator species
# plot(commB.fit.pb3.4[["lv.median"]][,1] ~ commB.fit.pb3.4[["lv.median"]][,2], col = as.numeric(habitatN$Habitat), pch = 16)  # to get just points, which we can then format as we want
# par(mfrow = c(1,1))
# # saveRDS(commB.fit.pb3.4, "commB.fit.pb3.4.RDS")

#### Binomial
commB.fit.b3.4.none <- boral(communityB, family = "binomial", num.lv = 2, row.eff = "none", mcmc.control = mcmc.control4, save.model = TRUE)
summary(commB.fit.b3.4)
par(mfrow = c(2,2))
plot(commB.fit.b3.4) ## Plots used in residual analysis, 
par(mfrow = c(1,1))
par(mfrow = c(1,2))
lvsplot(commB.fit.b3.4, biplot=FALSE, col = as.numeric(habitatN$Habitat))
plot(commB.fit.b3.4[["lv.median"]][,2] ~ commB.fit.b3.4[["lv.median"]][,1], col = as.numeric(habitatN$Habitat), pch = 16)  # to get just points, which we can then format as we want
par(mfrow = c(1,1))
saveRDS(commB.fit.b3.4, "analysis/commB.fit.b3.4.RDS")

# commB.fit.b3.4 <- readRDS("commB.fit.b3.4.RDS")
```

```{r betapart}
communityBbetapart <- bind_cols(habitatN, communityB)
communityBbetapart <- communityBbetapart %>% select(-c(Habitat:sprichness))

JCNF <- communityBbetapart %>% filter(habitatN$Habitat %in% c("JC", "NF")) %>% column_to_rownames(var="Site")
BBNF <- communityBbetapart %>% filter(habitatN$Habitat %in% c("BB", "NF")) %>% column_to_rownames(var="Site")
CLNF <- communityBbetapart %>% filter(habitatN$Habitat %in% c("CL", "NF")) %>% column_to_rownames(var="Site")
ECNF <- communityBbetapart %>% filter(habitatN$Habitat %in% c("EC", "NF")) %>% column_to_rownames(var="Site")
MFNF <- communityBbetapart %>% filter(habitatN$Habitat %in% c("MF", "NF")) %>% column_to_rownames(var="Site")

JCNF.multi.dist <- beta.multi(JCNF, index.family="jac")
BBNF.multi.dist <- beta.multi(BBNF, index.family="jac")
CLNF.multi.dist <- beta.multi(CLNF, index.family="jac")
ECNF.multi.dist <- beta.multi(ECNF, index.family="jac")
MFNF.multi.dist <- beta.multi(MFNF, index.family="jac")

multi.all <- list(JCNF = JCNF.multi.dist, BBNF = BBNF.multi.dist, CLNF = CLNF.multi.dist, ECNF =  ECNF.multi.dist, MFNF = MFNF.multi.dist)


ALL.dist <- communityBbetapart %>% column_to_rownames(var="Site") %>% beta.pair(index.family="jac")
ALL.dist.subset <- ALL.dist[["beta.jne"]]
ALL.dist.jne.jmds <- metaMDS(ALL.dist.subset)
ALL.dist.jne.jmds <- metaMDS(ALL.dist.subset, previous.best = ALL.dist.jne.jmds)
stressplot(ALL.dist.jne.jmds)
ALL.dist.subset <- ALL.dist[["beta.jtu"]]
ALL.dist.jtu.jmds <- metaMDS(ALL.dist.subset)
ALL.dist.jtu.jmds <- metaMDS(ALL.dist.subset, previous.best = ALL.dist.jne.jmds)
stressplot(ALL.dist.jtu.jmds)



par(mfrow=c(2,2))
with(habitatN, ordisurf(community.jmds, sprichness, main="All beta diversity", cex=0.5, col = "white", ylim = c(-0.5, 0.5), xlim = c(-0.4, 0.4)))
# plot(community.jmds, main = "All beta diversity", ylim = c(-0.4, 0.4))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[1]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))

plot(ALL.dist.jtu.jmds, main = "Turnover beta diversity only", ylim = c(-0.5, 0.5), xlim = c(-0.4, 0.4))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[1]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
    
plot(ALL.dist.jne.jmds, main = "Nestedness beta diversity only", ylim = c(-0.5, 0.5), xlim = c(-0.4, 0.4))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[1]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("CL"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
    
par(mfrow=c(1,1))

```


Redoing the above with forest plots only
```{r}
communityBforest <- communityB %>% filter(!(habitatN$Habitat %in% c("CL")))
communityBforest.jmds <- metaMDS(communityBforest, distance = "jaccard", trymax = 40, binary=TRUE)
communityBforest.jmds <- metaMDS(communityBforest, distance = "jaccard", binary = TRUE, previous.best = community.jmds)
stressplot(communityBforest.jmds)
plot(communityBforest.jmds)
habitatNforest <- habitatN %>% filter(!(Habitat %in% c("CL")))
habitatNforest <- droplevels(habitatNforest)
levels(habitatNforest$Habitat)


with(habitatNforest, ordisurf(communityBforest.jmds, sprichness, main="All beta diversity. Forest only", cex=0.5, col = "grey"))
    with(habitatNforest, ordispider(communityBforest.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
    with(habitatNforest, ordispider(communityBforest.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
    with(habitatNforest, ordispider(communityBforest.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
    with(habitatNforest, ordispider(communityBforest.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
    with(habitatNforest, ordispider(communityBforest.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
    
    
    
tabasco(communityBforest, use = communityBforest.jmds, labCol = habitatNforest$Habitat, col = heat.colors(1))



communityBbetapart <- bind_cols(habitatNforest, communityBforest)
communityBbetapart <- communityBbetapart %>% select(-c(Habitat:sprichness))
# 
JCNF <- communityBbetapart %>% filter(habitatNforest$Habitat %in% c("JC", "NF")) %>% column_to_rownames(var="Site")
BBNF <- communityBbetapart %>% filter(habitatNforest$Habitat %in% c("BB", "NF")) %>% column_to_rownames(var="Site")
ECNF <- communityBbetapart %>% filter(habitatNforest$Habitat %in% c("EC", "NF")) %>% column_to_rownames(var="Site")
MFNF <- communityBbetapart %>% filter(habitatNforest$Habitat %in% c("MF", "NF")) %>% column_to_rownames(var="Site")

JCNF.multi.dist <- beta.multi(JCNF, index.family="jac")
BBNF.multi.dist <- beta.multi(BBNF, index.family="jac")
ECNF.multi.dist <- beta.multi(ECNF, index.family="jac")
MFNF.multi.dist <- beta.multi(MFNF, index.family="jac")

multi.NF.all <- list(JCNF = JCNF.multi.dist, BBNF = BBNF.multi.dist, ECNF =  ECNF.multi.dist, MFNF = MFNF.multi.dist)

# comparing to MF
JCMF <- communityBbetapart %>% filter(habitatNforest$Habitat %in% c("JC", "MF")) %>% column_to_rownames(var="Site")
BBMF <- communityBbetapart %>% filter(habitatNforest$Habitat %in% c("BB", "MF")) %>% column_to_rownames(var="Site")
ECMF <- communityBbetapart %>% filter(habitatNforest$Habitat %in% c("EC", "MF")) %>% column_to_rownames(var="Site")

JCMF.multi.dist <- beta.multi(JCMF, index.family="jac")
BBMF.multi.dist <- beta.multi(BBMF, index.family="jac")
ECMF.multi.dist <- beta.multi(ECMF, index.family="jac")

multi.MF.all <- list(JCMF = JCMF.multi.dist, BBMF = BBMF.multi.dist, ECMF =  ECMF.multi.dist)



ALL.dist <- communityBbetapart %>% column_to_rownames(var="Site") %>% beta.pair(index.family="jac")
ALL.dist.subset <- ALL.dist[["beta.jne"]]
ALL.dist.jne.jmds <- metaMDS(ALL.dist.subset)
ALL.dist.jne.jmds <- metaMDS(ALL.dist.subset, previous.best = ALL.dist.jne.jmds)
stressplot(ALL.dist.jne.jmds)
ALL.dist.subset <- ALL.dist[["beta.jtu"]]
ALL.dist.jtu.jmds <- metaMDS(ALL.dist.subset)
ALL.dist.jtu.jmds <- metaMDS(ALL.dist.subset, previous.best = ALL.dist.jne.jmds)
stressplot(ALL.dist.jtu.jmds)


community.jmds <- communityBforest.jmds
habitatN <- habitatNforest

par(mfrow=c(2,2))
with(habitatN, ordisurf(community.jmds, sprichness, main="All beta diversity", cex=0.5, col = "white", ylim = c(-0.8, 0.8), xlim = c(-0.4, 0.4)))
# plot(community.jmds, main = "All beta diversity", ylim = c(-0.4, 0.4))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
    with(habitatN, ordispider(community.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))

plot(ALL.dist.jtu.jmds, main = "Turnover beta diversity only", ylim = c(-0.8, 0.8), xlim = c(-0.4, 0.4))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
    with(habitatN, ordispider(ALL.dist.jtu.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
    
plot(ALL.dist.jne.jmds, main = "Nestedness beta diversity only", ylim = c(-0.8, 0.8), xlim = c(-0.4, 0.4))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("BB"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("EC"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col=as.character(colvec[3]), alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("JC"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("MF"))))
    with(habitatN, ordispider(ALL.dist.jne.jmds, Habitat, cex=.5, draw="polygon", col="darkblue", alpha=20, kind="se", conf=0.95, label=TRUE, show.groups=(c("NF"))))
    
par(mfrow=c(1,1))
```

```{r}
protest(communityBforest.jmds, ALL.dist.jtu.jmds)
```

Call:
protest(X = communityBforest.jmds, Y = ALL.dist.jtu.jmds) 

Procrustes Sum of Squares (m12 squared):        0.3852 
Correlation in a symmetric Procrustes rotation: 0.7841 
Significance:  0.001 

Permutation: free
Number of permutations: 999

```{r}
protest(communityBforest.jmds, ALL.dist.jne.jmds)
```

Call:
protest(X = communityBforest.jmds, Y = ALL.dist.jne.jmds) 

Procrustes Sum of Squares (m12 squared):        0.9699 
Correlation in a symmetric Procrustes rotation: 0.1736 
Significance:  0.506 

Permutation: free
Number of permutations: 999

```{r boral forest only}
mcmc.control <- list(n.burnin = 10000, n.iteration = 40000, n.thin = 30)
mcmc.control <- list(n.burnin = 300, n.iteration = 3000, n.thin = 30)

#### Binomial
commB.forest.fit.b3.4.fixed <- boral(communityBforest, family = "binomial", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control, save.model = TRUE)
summary(commB.forest.fit.b3.4.fixed)
par(mfrow = c(2,2))
plot(commB.forest.fit.b3.4.fixed) ## Plots used in residual analysis, 
par(mfrow = c(1,1))
par(mfrow = c(1,2))
lvsplot(commB.forest.fit.b3.4.fixed, biplot=FALSE, col = as.numeric(habitatNforest$Habitat))
plot(commB.forest.fit.b3.4.fixed[["lv.median"]][,2] ~ commB.forest.fit.b3.4.fixed[["lv.median"]][,1], col = as.numeric(habitatNforest$Habitat), pch = 16)  # to get just points, which we can then format as we want
par(mfrow = c(1,1))
saveRDS(commB.forest.fit.b3.4.fixed, "analysis/commB.forest.fit.b3.4.fixed.RDS")
```


```{r betapart cerambycid example, eval=FALSE}
# Read the data for Northern and Southern European cerambycids
data(ceram.s)
data(ceram.n)

ceram.dist<-beta.pair(ceram.s, index.family="jac")
ceram.beta<-beta.multi(ceram.s, index.family="sor")

# Resample 100 times the multiple-site dissimilarities
# for 10 countries.
beta.ceram.s<-beta.sample(ceram.s, index.family="sor", sites=10, samples=100)
beta.ceram.n<-beta.sample(ceram.n, index.family="sor", sites=10, samples=100)

# Plot the distributions of beta.SIM in Southern Europe (red) 
# and Northern Europe (blue)
plot(density(beta.ceram.s$sampled.values$beta.SIM), col="red", xlim=c(0,1))
lines(density(beta.ceram.n$sampled.values$beta.SIM), col="blue")

# Compute the p-value of difference in beta.SIM between South and North 
# (i.e. the probability of finding in the North a higher value than 
# in the South)
p.value.beta.SIM<-length(which(beta.ceram.s$sampled.values$beta.SIM<
beta.ceram.n$sampled.values$beta.SIM))/100

p.value.beta.SIM
# The result is 0 and we used 100 samples, so p<0.01\
# 
# 
betapairout <- beta.pair(communityB, index.family="jac")
betapairout
```

```{r boral spider example, eval=FALSE}
library(mvabund) 
library(boral)
data(spider) 
y <- spider$abun #dim(y)
mcmc.control <- list(n.burnin = 10000, n.iteration = 40000, n.thin = 30, seed = 123)

## PART 1: Purely latent variable models assuming Poisson counts ## 
fit.lvmp <- boral(y = y, family = "poisson", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
summary(fit.lvmp)
fit.lvmp$hpdintervals
par(mfrow = c(2,2))
plot(fit.lvmp, ask = F, mfrow = c(2,2))
par(mfrow = c(1,1))
fit.lvmnb <- boral(y = y, family = "negative.binomial", num.lv = 2, row.eff = "fixed", mcmc.control = mcmc.control)
summary(fit.lvmnb)
par(mfrow = c(2,2))
plot(fit.lvmnb, ask = F, mfrow = c(2,2))
par(mfrow = c(1,1))
lvsplot(fit.lvmnb, alpha = 0.55, main = "Unconstrained biplot")


fit.nbnoX <- boral(y = y, family = "negative.binomial", num.lv = 2, save.model = TRUE, mcmc.control = mcmc.control)
rescors.null <- get.residual.cor(fit.nbnoX)

X <- scale(spider$x) 
fit.Xnb <- boral(y = y, X = X, family = "negative.binomial", num.lv = 2, save.model = TRUE, mcmc.control = mcmc.control)
summary(fit.Xnb)
par(mfrow = c(2,2))
plot(fit.Xnb, ask = F, mfrow = c(2,2))
par(mfrow = c(1,1))

envcors <- get.enviro.cor(fit.Xnb) 
rescors <- get.residual.cor(fit.Xnb)

library(corrplot) 
corrplot(envcors$sig.cor, type = "lower", diag = F, title = "Correlations due to covariates", mar = c(3,0.5,2,1), tl.srt = 45)
corrplot(rescors$sig.cor, type = "lower", diag = F, title = "Residual correlati ons", mar = c(3,0.5,2,1), tl.srt = 45)
lvsplot(fit.Xnb, main = "Residual biplot", alpha = 0.55)
rescors.null$trace
rescors$trace
(rescors.null$trace-rescors$trace)/rescors.null$trace
fit.Xnb.ssvsgp <- boral(y = y, X = X, num.lv = 2, family = "negative.binomial", save.model = T, ssvs.index = 1:ncol(X))
summary(fit.Xnb.ssvsgp)

fit.Xnb.ssvsind <- boral(y = y, X = X, num.lv = 2, family = "negative.binomial", save.model = T, ssvs.index = 0)
summary(fit.Xnb.ssvsind)
summary(fit.Xnb.ssvsind$ssvs.indcoefs.mean)

data(antTraits) 
y <- antTraits$abun 
sel.spp <- colSums(y>0)>4 # ant has more than four traits with measurements
y <- y[,sel.spp] 
X <- antTraits$env ## Scale covariates to ease interpretability

traits <- model.matrix(~., data = antTraits$traits[sel.spp,])

```

```{r boral spider example 2, eval=FALSE}
library(boral)

## Not run: 
## NOTE: The values below MUST NOT be used in a real application;
## they are only used here to make the examples run quick!!!
example.mcmc.control <- list(n.burnin = 10, n.iteration = 100, 
     n.thin = 1)

library(mvabund) ## Load a dataset from the mvabund package
data(spider)
y <- spider$abun
n <- nrow(y); p <- ncol(y); 

X <- scale(spider$x)
spider.fit.nb <- boral(y, X = X, family = "negative.binomial", 
	num.lv = 2, mcmc.control = example.mcmc.control)


## Do separate line plots for all the coefficients of X
par(mfrow=c(2,3), mar = c(5,6,1,1))
sapply(colnames(spider.fit.nb$X), coefsplot, 
	spider.fit.nb)

## End(Not run)
```

```{r PD calc, eval=FALSE} 

########### phylocurve ##############

otu_table <- communityB
tree <- read.tree("./data/reIDotu443_outgroupOnychophora_tree.newick")

pd <- phylodiv(otu_table, tree)
pd <- phylocurve(otu_table, tree, stepm = 10, subsampling = "species", replace = FALSE)


####### beta diversity ######
#### PCA 
#install.packages("SparseM") ## need by library 'car'
#library(foreign)
#library(vegan)
#library(car)
#commNosrB <- commNosr
#commNosrB[commNosrB<3] <- 0 # according before results and field work experience, #JC forest seems get more alpha diversity. so drop those single read and double #reads cell
#commNosrB[commNosrB>1] <- 1
#
#hab <- habitat[,2:4]
#comm.pca <- rda(commNosrB)
#comm.pca <- rda(commNosrB~Habitat,habitat)
#comm.pca <- rda(commNosrB~Habitat*Altitude*Weather,habitat)
#summary(comm.pca)
#plot(comm.pca)


```



webpages to learn from 

http://evomics.org/wp-content/uploads/2016/01/phyloseq-Lab-01-Answers.html
http://rdp.cme.msu.edu/tutorials/RDPtutorial_CONTENTS.html
http://rdp.cme.msu.edu/tutorials/stats/using_rdp_output_with_phyloseq.html#supervised
http://rdp.cme.msu.edu/tutorials/stats/RDPtutorial_statistics.html
https://github.com/hallamlab/mp_tutorial/wiki/Taxonomic-Analysis
https://github.com/eheinzen/arsenal

https://grunwaldlab.github.io/metacoder_documentation


